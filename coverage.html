
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">cerberus/api/api.go (92.7%)</option>
				
				<option value="file1">cerberus/api/handlers.go (80.6%)</option>
				
				<option value="file2">cerberus/api/middleware.go (76.8%)</option>
				
				<option value="file3">cerberus/api/validation.go (78.3%)</option>
				
				<option value="file4">cerberus/config/config.go (95.2%)</option>
				
				<option value="file5">cerberus/core/alert.go (100.0%)</option>
				
				<option value="file6">cerberus/core/rule.go (100.0%)</option>
				
				<option value="file7">cerberus/core/schema.go (100.0%)</option>
				
				<option value="file8">cerberus/detect/actions.go (65.9%)</option>
				
				<option value="file9">cerberus/detect/detector.go (93.9%)</option>
				
				<option value="file10">cerberus/detect/engine.go (84.3%)</option>
				
				<option value="file11">cerberus/detect/eventreplay.go (3.8%)</option>
				
				<option value="file12">cerberus/detect/loader.go (30.2%)</option>
				
				<option value="file13">cerberus/ingest/base.go (71.0%)</option>
				
				<option value="file14">cerberus/ingest/cef.go (100.0%)</option>
				
				<option value="file15">cerberus/ingest/json.go (90.7%)</option>
				
				<option value="file16">cerberus/ingest/parsers.go (91.1%)</option>
				
				<option value="file17">cerberus/ingest/syslog.go (100.0%)</option>
				
				<option value="file18">cerberus/main.go (5.9%)</option>
				
				<option value="file19">cerberus/storage/actionstorage.go (66.7%)</option>
				
				<option value="file20">cerberus/storage/alertstorage.go (52.6%)</option>
				
				<option value="file21">cerberus/storage/correlationrulestorage.go (71.4%)</option>
				
				<option value="file22">cerberus/storage/mock_action.go (73.1%)</option>
				
				<option value="file23">cerberus/storage/mock_alert.go (78.1%)</option>
				
				<option value="file24">cerberus/storage/mock_correlationrule.go (77.5%)</option>
				
				<option value="file25">cerberus/storage/mock_cursor.go (87.8%)</option>
				
				<option value="file26">cerberus/storage/mock_event.go (76.7%)</option>
				
				<option value="file27">cerberus/storage/mongodb.go (46.6%)</option>
				
				<option value="file28">cerberus/storage/retention.go (76.5%)</option>
				
				<option value="file29">cerberus/storage/rulestorage.go (73.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package api Cerberus SIEM API
//
//        @title                        Cerberus SIEM API
//        @version                1.0
//        @description        API for managing Cerberus SIEM events, alerts, rules, and configuration
//        @termsOfService        http://swagger.io/terms/
//
// @license.name        MIT
// @license.url        https://opensource.org/licenses/MIT
//
// @host                localhost:8081
// @BasePath        /
// @securityDefinitions.apikey        ApiKeyAuth
// @in                                                        header
// @name                                                Authorization
// @description                                Enter your API key
package api

import (
        "context"
        "net/http"
        "sync"
        "time"

        "cerberus/config"
        "cerberus/core"
        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/swaggo/http-swagger"
        "go.uber.org/zap"
        "golang.org/x/time/rate"
)

// rateLimiterEntry holds a rate limiter with last seen time
type rateLimiterEntry struct {
        limiter  *rate.Limiter
        lastSeen time.Time
}

// authFailureEntry holds auth failure count and last failure time
type authFailureEntry struct {
        count    int
        lastFail time.Time
}

// EventStorer interface for event storage
type EventStorer interface {
        GetEvents(limit int) ([]core.Event, error)
        GetEventCount() (int64, error)
        GetEventCountsByMonth() ([]map[string]interface{}, error)
}

// AlertStorer interface for alert storage
type AlertStorer interface {
        GetAlerts(limit int) ([]core.Alert, error)
        GetAlertCount() (int64, error)
        GetAlertCountsByMonth() ([]map[string]interface{}, error)
        AcknowledgeAlert(id string) error
        DismissAlert(id string) error
}

// RuleStorer interface for rule storage
type RuleStorer interface {
        GetRules() ([]core.Rule, error)
        GetRule(id string) (*core.Rule, error)
        CreateRule(rule *core.Rule) error
        UpdateRule(id string, rule *core.Rule) error
        DeleteRule(id string) error
}

// ActionStorer interface for action storage
type ActionStorer interface {
        GetActions() ([]core.Action, error)
        GetAction(id string) (*core.Action, error)
        CreateAction(action *core.Action) error
        UpdateAction(id string, action *core.Action) error
        DeleteAction(id string) error
}

// CorrelationRuleStorer interface for correlation rule storage
type CorrelationRuleStorer interface {
        GetCorrelationRules() ([]core.CorrelationRule, error)
        GetCorrelationRule(id string) (*core.CorrelationRule, error)
        CreateCorrelationRule(rule *core.CorrelationRule) error
        UpdateCorrelationRule(id string, rule *core.CorrelationRule) error
        DeleteCorrelationRule(id string) error
}

// API holds the API server
type API struct {
        router                 *mux.Router
        server                 *http.Server
        eventStorage           EventStorer
        alertStorage           AlertStorer
        ruleStorage            RuleStorer
        actionStorage          ActionStorer
        correlationRuleStorage CorrelationRuleStorer
        config                 *config.Config
        logger                 *zap.SugaredLogger
        rateLimiters           map[string]*rateLimiterEntry
        rateLimitersMu         sync.Mutex
        authFailures           map[string]*authFailureEntry
        authFailuresMu         sync.Mutex
        stopCh                 chan struct{}
}

// NewAPI creates a new API server
func NewAPI(eventStorage EventStorer, alertStorage AlertStorer, ruleStorage RuleStorer, actionStorage ActionStorer, correlationRuleStorage CorrelationRuleStorer, config *config.Config, logger *zap.SugaredLogger) *API <span class="cov10" title="71">{
        api := &amp;API{
                router:                 mux.NewRouter(),
                eventStorage:           eventStorage,
                alertStorage:           alertStorage,
                ruleStorage:            ruleStorage,
                actionStorage:          actionStorage,
                correlationRuleStorage: correlationRuleStorage,
                config:                 config,
                logger:                 logger,
                rateLimiters:           make(map[string]*rateLimiterEntry),
                authFailures:           make(map[string]*authFailureEntry),
                stopCh:                 make(chan struct{}),
        }
        api.setupRoutes()
        go api.cleanupRateLimiters()
        return api
}</span>

// setupRoutes sets up the API routes
func (a *API) setupRoutes() <span class="cov10" title="71">{
        a.router.Use(a.corsMiddleware)
        a.router.Use(a.rateLimitMiddleware)
        if a.config.Auth.Enabled </span><span class="cov2" title="2">{
                a.router.Use(a.basicAuthMiddleware)
        }</span>
        <span class="cov10" title="71">a.router.HandleFunc("/api/events", a.getEvents).Methods("GET")
        a.router.HandleFunc("/api/alerts", a.getAlerts).Methods("GET")
        a.router.HandleFunc("/api/alerts/{id}/acknowledge", a.acknowledgeAlert).Methods("POST")
        a.router.HandleFunc("/api/alerts/{id}/dismiss", a.dismissAlert).Methods("POST")
        a.router.HandleFunc("/api/rules", a.getRules).Methods("GET")
        a.router.HandleFunc("/api/rules", a.createRule).Methods("POST")
        a.router.HandleFunc("/api/rules/{id}", a.getRule).Methods("GET")
        a.router.HandleFunc("/api/rules/{id}", a.updateRule).Methods("PUT")
        a.router.HandleFunc("/api/rules/{id}", a.deleteRule).Methods("DELETE")
        a.router.HandleFunc("/api/actions", a.getActions).Methods("GET")
        a.router.HandleFunc("/api/actions", a.createAction).Methods("POST")
        a.router.HandleFunc("/api/actions/{id}", a.getAction).Methods("GET")
        a.router.HandleFunc("/api/actions/{id}", a.updateAction).Methods("PUT")
        a.router.HandleFunc("/api/actions/{id}", a.deleteAction).Methods("DELETE")
        a.router.HandleFunc("/api/correlation-rules", a.getCorrelationRules).Methods("GET")
        a.router.HandleFunc("/api/correlation-rules", a.createCorrelationRule).Methods("POST")
        a.router.HandleFunc("/api/correlation-rules/{id}", a.getCorrelationRule).Methods("GET")
        a.router.HandleFunc("/api/correlation-rules/{id}", a.updateCorrelationRule).Methods("PUT")
        a.router.HandleFunc("/api/correlation-rules/{id}", a.deleteCorrelationRule).Methods("DELETE")
        a.router.HandleFunc("/api/listeners", a.getListeners).Methods("GET")
        a.router.HandleFunc("/api/dashboard", a.getDashboardStats).Methods("GET")
        a.router.HandleFunc("/api/dashboard/chart", a.getDashboardChart).Methods("GET")
        a.router.HandleFunc("/health", a.healthCheck).Methods("GET")
        a.router.Handle("/metrics", promhttp.Handler())

        // Swagger UI
        a.router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)</span>
}

// Start starts the API server
func (a *API) Start(port string) error <span class="cov1" title="1">{
        a.server = &amp;http.Server{
                Addr:    port,
                Handler: a.router,
        }
        return a.server.ListenAndServe()
}</span>

// StartTLS starts the API server with TLS
func (a *API) StartTLS(port, certFile, keyFile string) error <span class="cov0" title="0">{
        a.server = &amp;http.Server{
                Addr:    port,
                Handler: a.router,
        }
        return a.server.ListenAndServeTLS(certFile, keyFile)
}</span>

// Stop stops the API server
func (a *API) Stop(ctx context.Context) error <span class="cov1" title="1">{
        close(a.stopCh)
        if a.server != nil </span><span class="cov1" title="1">{
                return a.server.Shutdown(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "cerberus/core"
        "cerberus/storage"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
)

// getEvents returns recent events
func (a *API) getEvents(w http.ResponseWriter, r *http.Request) <span class="cov10" title="6">{
        if a.eventStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Event storage not available", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov9" title="5">limit := 100
        if l := r.URL.Query().Get("limit"); l != "" </span><span class="cov6" title="3">{
                if parsed, err := strconv.Atoi(l); err == nil &amp;&amp; parsed &gt; 0 &amp;&amp; parsed &lt;= 1000 </span><span class="cov1" title="1">{
                        limit = parsed
                }</span>
        }
        <span class="cov9" title="5">events, err := a.eventStorage.GetEvents(limit)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, fmt.Sprintf("Failed to get events: %v", err), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov7" title="4">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(events)</span>
}

// getAlerts godoc
//
//        @Summary                Get alerts
//        @Description        Returns a list of alerts
//        @Tags                        alerts
//        @Accept                        json
//        @Produce                json
//        @Success                200        {array}                core.Alert
//        @Router                        /api/alerts [get]
func (a *API) getAlerts(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        if a.alertStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Alert storage not available", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov4" title="2">alerts, err := a.alertStorage.GetAlerts(100)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, fmt.Sprintf("Failed to get alerts: %v", err), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(alerts)</span>
}

// acknowledgeAlert godoc
//
//        @Summary                Acknowledge alert
//        @Description        Acknowledge an alert by ID
//        @Tags                        alerts
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path                string        true        "Alert ID"
//        @Success                200        {string}        string        "Alert acknowledged"
//        @Failure                404        {string}        string        "Alert not found"
//        @Failure                503        {string}        string        "Alert storage not available"
//        @Router                        /api/alerts/{id}/acknowledge [post]
func (a *API) acknowledgeAlert(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        if a.alertStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Alert storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov6" title="3">vars := mux.Vars(r)
        id := vars["id"]

        if err := a.alertStorage.AcknowledgeAlert(id); err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, storage.ErrAlertNotFound) </span><span class="cov1" title="1">{
                        http.Error(w, "Alert not found", http.StatusNotFound)
                }</span> else<span class="cov1" title="1"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov4" title="2">return</span>
        }

        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"status": "acknowledged"})</span>
}

// dismissAlert godoc
//
//        @Summary                Dismiss alert
//        @Description        Dismiss an alert by ID
//        @Tags                        alerts
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path                string        true        "Alert ID"
//        @Success                200        {object}        map[string]string
//        @Failure                404        {string}        string        "Alert not found"
//        @Failure                503        {string}        string        "Alert storage not available"
//        @Router                        /api/alerts/{id}/dismiss [post]
func (a *API) dismissAlert(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        if a.alertStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Alert storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov6" title="3">vars := mux.Vars(r)
        id := vars["id"]

        if err := a.alertStorage.DismissAlert(id); err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, storage.ErrAlertNotFound) </span><span class="cov1" title="1">{
                        http.Error(w, "Alert not found", http.StatusNotFound)
                }</span> else<span class="cov1" title="1"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov4" title="2">return</span>
        }

        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"status": "dismissed"})</span>
}

// getRules godoc
//
//        @Summary                Get rules
//        @Description        Returns a list of all detection rules
//        @Tags                        rules
//        @Accept                        json
//        @Produce                json
//        @Success                200        {array}                core.Rule
//        @Failure                503        {string}        string        "Rule storage not available"
//        @Router                        /api/rules [get]
func (a *API) getRules(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        if a.ruleStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov4" title="2">rules, err := a.ruleStorage.GetRules()
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(rules)</span>
}

// getRule godoc
//
//        @Summary                Get rule
//        @Description        Get a detection rule by ID
//        @Tags                        rules
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path                string        true        "Rule ID"
//        @Success                200        {object}        core.Rule
//        @Failure                404        {string}        string        "Rule not found"
//        @Failure                503        {string}        string        "Rule storage not available"
//        @Router                        /api/rules/{id} [get]
func (a *API) getRule(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        if a.ruleStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov6" title="3">vars := mux.Vars(r)
        id := vars["id"]

        rule, err := a.ruleStorage.GetRule(id)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, storage.ErrRuleNotFound) </span><span class="cov1" title="1">{
                        http.Error(w, "Rule not found", http.StatusNotFound)
                }</span> else<span class="cov1" title="1"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov4" title="2">return</span>
        }

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(rule)</span>
}

// createRule godoc
//
//        @Summary                Create rule
//        @Description        Create a new detection rule
//        @Tags                        rules
//        @Accept                        json
//        @Produce                json
//        @Param                        rule        body                core.Rule        true        "Rule object"
//        @Success                201        {object}        core.Rule
//        @Failure                400        {string}        string        "Invalid JSON"
//        @Failure                503        {string}        string        "Rule storage not available"
//        @Router                        /api/rules [post]
func (a *API) createRule(w http.ResponseWriter, r *http.Request) <span class="cov9" title="5">{
        if a.ruleStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov7" title="4">var rule core.Rule
        if err := json.NewDecoder(r.Body).Decode(&amp;rule); err != nil </span><span class="cov1" title="1">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="3">if err := validateRule(&amp;rule); err != nil </span><span class="cov1" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">rule.ID = uuid.New().String()

        if err := a.ruleStorage.CreateRule(&amp;rule); err != nil </span><span class="cov1" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(rule)</span>
}

// updateRule godoc
//
//        @Summary                Update rule
//        @Description        Update an existing detection rule
//        @Tags                        rules
//        @Accept                        json
//        @Produce                json
//        @Param                        id                path                string                true        "Rule ID"
//        @Param                        rule        body                core.Rule        true        "Rule object"
//        @Success                200                {object}        core.Rule
//        @Failure                400                {string}        string                "Invalid JSON"
//        @Failure                404                {string}        string                "Rule not found"
//        @Failure                503                {string}        string                "Rule storage not available"
//        @Router                        /api/rules/{id} [put]
func (a *API) updateRule(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        if a.ruleStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov4" title="2">vars := mux.Vars(r)
        id := vars["id"]

        var rule core.Rule
        if err := json.NewDecoder(r.Body).Decode(&amp;rule); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">if err := validateRule(&amp;rule); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">rule.ID = id

        if err := a.ruleStorage.UpdateRule(id, &amp;rule); err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, storage.ErrRuleNotFound) </span><span class="cov1" title="1">{
                        http.Error(w, "Rule not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(rule)</span>
}

// deleteRule godoc
//
//        @Summary                Delete rule
//        @Description        Delete a detection rule by ID
//        @Tags                        rules
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path                string        true        "Rule ID"
//        @Success                200        {string}        string        "Rule deleted"
//        @Failure                404        {string}        string        "Rule not found"
//        @Failure                503        {string}        string        "Rule storage not available"
//        @Router                        /api/rules/{id} [delete]
func (a *API) deleteRule(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if a.ruleStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov1" title="1">vars := mux.Vars(r)
        id := vars["id"]

        if err := a.ruleStorage.DeleteRule(id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, storage.ErrRuleNotFound) </span><span class="cov0" title="0">{
                        http.Error(w, "Rule not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})</span>
}

// getActions godoc
//
//        @Summary                Get actions
//        @Description        Returns a list of all actions
//        @Tags                        actions
//        @Accept                        json
//        @Produce                json
//        @Success                200        {array}                core.Action
//        @Failure                503        {string}        string        "Action storage not available"
//        @Router                        /api/actions [get]
func (a *API) getActions(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if a.actionStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Action storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov1" title="1">actions, err := a.actionStorage.GetActions()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(actions)</span>
}

// getAction godoc
//
//        @Summary                Get action
//        @Description        Get an action by ID
//        @Tags                        actions
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path                string        true        "Action ID"
//        @Success                200        {object}        core.Action
//        @Failure                404        {string}        string        "Action not found"
//        @Failure                503        {string}        string        "Action storage not available"
//        @Router                        /api/actions/{id} [get]
func (a *API) getAction(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        if a.actionStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Action storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov6" title="3">vars := mux.Vars(r)
        id := vars["id"]

        action, err := a.actionStorage.GetAction(id)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, storage.ErrActionNotFound) </span><span class="cov1" title="1">{
                        http.Error(w, "Action not found", http.StatusNotFound)
                }</span> else<span class="cov1" title="1"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov4" title="2">return</span>
        }

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(action)</span>
}

// createAction godoc
//
//        @Summary                Create action
//        @Description        Create a new action
//        @Tags                        actions
//        @Accept                        json
//        @Produce                json
//        @Param                        action        body                core.Action        true        "Action object"
//        @Success                201                {object}        core.Action
//        @Failure                400                {string}        string                "Invalid JSON"
//        @Failure                503                {string}        string                "Action storage not available"
//        @Router                        /api/actions [post]
func (a *API) createAction(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if a.actionStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Action storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov1" title="1">var action core.Action
        if err := json.NewDecoder(r.Body).Decode(&amp;action); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">if err := validateAction(&amp;action); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">action.ID = uuid.New().String()

        if err := a.actionStorage.CreateAction(&amp;action); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(action)</span>
}

// updateAction godoc
//
//        @Summary                Update action
//        @Description        Update an existing action
//        @Tags                        actions
//        @Accept                        json
//        @Produce                json
//        @Param                        id                        path                string                true        "Action ID"
//        @Param                        action                body                core.Action        true        "Action object"
//        @Success                200                        {object}        core.Action
//        @Failure                400                        {string}        string                "Invalid JSON"
//        @Failure                404                        {string}        string                "Action not found"
//        @Failure                503                        {string}        string                "Action storage not available"
//        @Router                        /api/actions/{id} [put]
func (a *API) updateAction(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        if a.actionStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Action storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov4" title="2">vars := mux.Vars(r)
        id := vars["id"]

        var action core.Action
        if err := json.NewDecoder(r.Body).Decode(&amp;action); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">if err := validateAction(&amp;action); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">action.ID = id

        if err := a.actionStorage.UpdateAction(id, &amp;action); err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, storage.ErrActionNotFound) </span><span class="cov1" title="1">{
                        http.Error(w, "Action not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(action)</span>
}

// deleteAction godoc
//
//        @Summary                Delete action
//        @Description        Delete an action by ID
//        @Tags                        actions
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path                string        true        "Action ID"
//        @Success                200        {string}        string        "Action deleted"
//        @Failure                404        {string}        string        "Action not found"
//        @Failure                503        {string}        string        "Action storage not available"
//        @Router                        /api/actions/{id} [delete]
func (a *API) deleteAction(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if a.actionStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Action storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov1" title="1">vars := mux.Vars(r)
        id := vars["id"]

        if err := a.actionStorage.DeleteAction(id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, storage.ErrActionNotFound) </span><span class="cov0" title="0">{
                        http.Error(w, "Action not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})</span>
}

// getCorrelationRules godoc
//
//        @Summary                Get correlation rules
//        @Description        Returns a list of all correlation rules
//        @Tags                        correlation-rules
//        @Accept                        json
//        @Produce                json
//        @Success                200        {array}                core.CorrelationRule
//        @Failure                503        {string}        string        "Correlation rule storage not available"
//        @Router                        /api/correlation-rules [get]
func (a *API) getCorrelationRules(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        if a.correlationRuleStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Correlation rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov4" title="2">rules, err := a.correlationRuleStorage.GetCorrelationRules()
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(rules)</span>
}

// getCorrelationRule godoc
//
//        @Summary                Get correlation rule
//        @Description        Get a correlation rule by ID
//        @Tags                        correlation-rules
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path                string        true        "Correlation Rule ID"
//        @Success                200        {object}        core.CorrelationRule
//        @Failure                404        {string}        string        "Correlation rule not found"
//        @Failure                503        {string}        string        "Correlation rule storage not available"
//        @Router                        /api/correlation-rules/{id} [get]
func (a *API) getCorrelationRule(w http.ResponseWriter, r *http.Request) <span class="cov7" title="4">{
        if a.correlationRuleStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Correlation rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov6" title="3">vars := mux.Vars(r)
        id := vars["id"]

        rule, err := a.correlationRuleStorage.GetCorrelationRule(id)
        if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, storage.ErrCorrelationRuleNotFound) </span><span class="cov1" title="1">{
                        http.Error(w, "Correlation rule not found", http.StatusNotFound)
                }</span> else<span class="cov1" title="1"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov4" title="2">return</span>
        }

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(rule)</span>
}

// createCorrelationRule godoc
//
//        @Summary                Create correlation rule
//        @Description        Create a new correlation rule
//        @Tags                        correlation-rules
//        @Accept                        json
//        @Produce                json
//        @Param                        rule        body                core.CorrelationRule        true        "Correlation Rule object"
//        @Success                201                {object}        core.CorrelationRule
//        @Failure                400                {string}        string                                "Invalid JSON"
//        @Failure                503                {string}        string                                "Correlation rule storage not available"
//        @Router                        /api/correlation-rules [post]
func (a *API) createCorrelationRule(w http.ResponseWriter, r *http.Request) <span class="cov9" title="5">{
        if a.correlationRuleStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Correlation rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov7" title="4">var rule core.CorrelationRule
        if err := json.NewDecoder(r.Body).Decode(&amp;rule); err != nil </span><span class="cov1" title="1">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="3">if err := validateCorrelationRule(&amp;rule); err != nil </span><span class="cov1" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">rule.ID = uuid.New().String()

        if err := a.correlationRuleStorage.CreateCorrelationRule(&amp;rule); err != nil </span><span class="cov1" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(rule)</span>
}

// updateCorrelationRule godoc
//
//        @Summary                Update correlation rule
//        @Description        Update an existing correlation rule
//        @Tags                        correlation-rules
//        @Accept                        json
//        @Produce                json
//        @Param                        id                path                string                                true        "Correlation Rule ID"
//        @Param                        rule        body                core.CorrelationRule        true        "Correlation Rule object"
//        @Success                200                {object}        core.CorrelationRule
//        @Failure                400                {string}        string                                "Invalid JSON"
//        @Failure                404                {string}        string                                "Correlation rule not found"
//        @Failure                503                {string}        string                                "Correlation rule storage not available"
//        @Router                        /api/correlation-rules/{id} [put]
func (a *API) updateCorrelationRule(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        if a.correlationRuleStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Correlation rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov4" title="2">vars := mux.Vars(r)
        id := vars["id"]

        var rule core.CorrelationRule
        if err := json.NewDecoder(r.Body).Decode(&amp;rule); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">if err := validateCorrelationRule(&amp;rule); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov4" title="2">rule.ID = id

        if err := a.correlationRuleStorage.UpdateCorrelationRule(id, &amp;rule); err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, storage.ErrCorrelationRuleNotFound) </span><span class="cov1" title="1">{
                        http.Error(w, "Correlation rule not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(rule)</span>
}

// deleteCorrelationRule godoc
//
//        @Summary                Delete correlation rule
//        @Description        Delete a correlation rule by ID
//        @Tags                        correlation-rules
//        @Accept                        json
//        @Produce                json
//        @Param                        id        path                string        true        "Correlation Rule ID"
//        @Success                200        {string}        string        "Correlation rule deleted"
//        @Failure                404        {string}        string        "Correlation rule not found"
//        @Failure                503        {string}        string        "Correlation rule storage not available"
//        @Router                        /api/correlation-rules/{id} [delete]
func (a *API) deleteCorrelationRule(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if a.correlationRuleStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Correlation rule storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov1" title="1">vars := mux.Vars(r)
        id := vars["id"]

        if err := a.correlationRuleStorage.DeleteCorrelationRule(id); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, storage.ErrCorrelationRuleNotFound) </span><span class="cov0" title="0">{
                        http.Error(w, "Correlation rule not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov1" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})</span>
}

// getListeners godoc
//
//        @Summary                Get listeners
//        @Description        Returns information about active listeners
//        @Tags                        system
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        map[string]interface{}
//        @Router                        /api/listeners [get]
func (a *API) getListeners(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        listeners := map[string]interface{}{
                "syslog": map[string]interface{}{
                        "host": a.config.Listeners.Syslog.Host,
                        "port": a.config.Listeners.Syslog.Port,
                },
                "cef": map[string]interface{}{
                        "host": a.config.Listeners.CEF.Host,
                        "port": a.config.Listeners.CEF.Port,
                },
                "json": map[string]interface{}{
                        "host": a.config.Listeners.JSON.Host,
                        "port": a.config.Listeners.JSON.Port,
                        "tls":  a.config.Listeners.JSON.TLS,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(listeners)
}</span>

// getDashboardStats godoc
//
//        @Summary                Get dashboard stats
//        @Description        Returns dashboard statistics
//        @Tags                        dashboard
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        map[string]interface{}
//        @Failure                503        {string}        string        "Storage not available"
//        @Router                        /api/dashboard [get]
func (a *API) getDashboardStats(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        if a.eventStorage == nil || a.alertStorage == nil </span><span class="cov0" title="0">{
                http.Error(w, "Storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov1" title="1">eventCount, err := a.eventStorage.GetEventCount()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to get event count: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">alertCount, err := a.alertStorage.GetAlertCount()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to get alert count: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">stats := map[string]interface{}{
                "events": eventCount,
                "alerts": alertCount,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

// getDashboardChart godoc
//
//        @Summary                Get dashboard chart data
//        @Description        Returns historical chart data for events and alerts
//        @Tags                        dashboard
//        @Accept                        json
//        @Produce                json
//        @Success                200        {array}        map[string]interface{}
//        @Failure                503        {string}        string        "Storage not available"
//        @Router                        /api/dashboard/chart [get]
func (a *API) getDashboardChart(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        if a.eventStorage == nil || a.alertStorage == nil </span><span class="cov1" title="1">{
                http.Error(w, "Storage not available", http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov4" title="2">eventData, err := a.eventStorage.GetEventCountsByMonth()
        if err != nil </span><span class="cov1" title="1">{
                a.logger.Errorw("Failed to get event counts", "error", err)
                http.Error(w, "Failed to retrieve event data", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">alertData, err := a.alertStorage.GetAlertCountsByMonth()
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Errorw("Failed to get alert counts", "error", err)
                http.Error(w, "Failed to retrieve alert data", http.StatusInternalServerError)
                return
        }</span>

        // Merge event and alert data
        <span class="cov1" title="1">alertMap := make(map[string]int)
        for _, alert := range alertData </span><span class="cov1" title="1">{
                if name, ok := alert["name"].(string); ok </span><span class="cov1" title="1">{
                        if a, ok := alert["alerts"].(int); ok </span><span class="cov1" title="1">{
                                alertMap[name] = a
                        }</span>
                }
        }
        <span class="cov1" title="1">chartData := make([]map[string]interface{}, len(eventData))
        for i, event := range eventData </span><span class="cov1" title="1">{
                name := event["name"]
                events := event["events"]
                alerts := 0
                if nameStr, ok := name.(string); ok </span><span class="cov1" title="1">{
                        alerts = alertMap[nameStr]
                }</span>
                <span class="cov1" title="1">chartData[i] = map[string]interface{}{
                        "name":   name,
                        "events": events,
                        "alerts": alerts,
                }</span>
        }

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(chartData)</span>
}

// healthCheck godoc
//
//        @Summary                Health check
//        @Description        Returns the health status of the service
//        @Tags                        system
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        map[string]string
//        @Router                        /health [get]
func (a *API) healthCheck(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        status := "healthy"
        if a.eventStorage == nil || a.alertStorage == nil </span><span class="cov1" title="1">{
                status = "degraded"
        }</span>

        <span class="cov4" title="2">response := map[string]string{
                "status": status,
                "time":   time.Now().Format(time.RFC3339),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "net/http"
        "time"

        "golang.org/x/crypto/bcrypt"
        "golang.org/x/time/rate"
)

// rateLimitMiddleware provides rate limiting per IP
func (a *API) rateLimitMiddleware(next http.Handler) http.Handler <span class="cov2" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="3">{
                ip := getRealIP(r, a.config.API.TrustProxy)
                a.rateLimitersMu.Lock()
                entry, exists := a.rateLimiters[ip]
                if !exists </span><span class="cov2" title="2">{
                        entry = &amp;rateLimiterEntry{
                                limiter:  rate.NewLimiter(rate.Limit(a.config.API.RateLimit.RequestsPerSecond), a.config.API.RateLimit.Burst),
                                lastSeen: time.Now(),
                        }
                        a.rateLimiters[ip] = entry
                }</span> else<span class="cov1" title="1"> {
                        entry.lastSeen = time.Now()
                }</span>
                <span class="cov3" title="3">a.rateLimitersMu.Unlock()

                if !entry.limiter.Allow() </span><span class="cov1" title="1">{
                        http.Error(w, "Too many requests", http.StatusTooManyRequests)
                        return
                }</span>
                <span class="cov2" title="2">next.ServeHTTP(w, r)</span>
        })
}

// cleanupRateLimiters periodically removes inactive rate limiters and auth failures to prevent memory leaks
func (a *API) cleanupRateLimiters() <span class="cov10" title="71">{
        ticker := time.NewTicker(1 * time.Hour)
        defer ticker.Stop()
        for </span><span class="cov10" title="71">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        a.rateLimitersMu.Lock()
                        for ip, entry := range a.rateLimiters </span><span class="cov0" title="0">{
                                if time.Since(entry.lastSeen) &gt; 1*time.Hour </span><span class="cov0" title="0">{
                                        delete(a.rateLimiters, ip)
                                }</span>
                        }
                        <span class="cov0" title="0">a.rateLimitersMu.Unlock()

                        a.authFailuresMu.Lock()
                        for ip, entry := range a.authFailures </span><span class="cov0" title="0">{
                                if time.Since(entry.lastFail) &gt; 1*time.Hour </span><span class="cov0" title="0">{
                                        delete(a.authFailures, ip)
                                }</span>
                        }
                        <span class="cov0" title="0">a.authFailuresMu.Unlock()</span>
                case &lt;-a.stopCh:<span class="cov1" title="1">
                        return</span>
                }
        }
}

// corsMiddleware adds CORS headers
func (a *API) corsMiddleware(next http.Handler) http.Handler <span class="cov2" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov2" title="2">{
                origin := r.Header.Get("Origin")
                for _, allowed := range a.config.API.AllowedOrigins </span><span class="cov1" title="1">{
                        if origin == allowed </span><span class="cov1" title="1">{
                                w.Header().Set("Access-Control-Allow-Origin", origin)
                                break</span>
                        }
                }
                <span class="cov2" title="2">w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                w.Header().Set("Access-Control-Allow-Credentials", "true")

                // Add HSTS if TLS is enabled
                if a.config.API.TLS </span><span class="cov1" title="1">{
                        w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                }</span>

                <span class="cov2" title="2">if r.Method == "OPTIONS" </span><span class="cov1" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov1" title="1">next.ServeHTTP(w, r)</span>
        })
}

// basicAuthMiddleware provides basic authentication with rate limiting for failed attempts
func (a *API) basicAuthMiddleware(next http.Handler) http.Handler <span class="cov2" title="2">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov2" title="2">{
                ip := getRealIP(r, a.config.API.TrustProxy)

                // Check if IP is blocked due to too many failures
                a.authFailuresMu.Lock()
                entry, exists := a.authFailures[ip]
                if exists &amp;&amp; entry.count &gt;= 5 &amp;&amp; time.Since(entry.lastFail) &lt; 10*time.Minute </span><span class="cov0" title="0">{
                        a.authFailuresMu.Unlock()
                        a.logger.Errorf("Too many failed auth attempts from IP: %s", ip)
                        http.Error(w, "Too many requests", http.StatusTooManyRequests)
                        return
                }</span>
                <span class="cov2" title="2">a.authFailuresMu.Unlock()

                username, password, ok := r.BasicAuth()
                if !ok || username != a.config.Auth.Username || bcrypt.CompareHashAndPassword([]byte(a.config.Auth.HashedPassword), []byte(password)) != nil </span><span class="cov1" title="1">{
                        // Increment failure count
                        a.authFailuresMu.Lock()
                        if !exists </span><span class="cov1" title="1">{
                                a.authFailures[ip] = &amp;authFailureEntry{count: 1, lastFail: time.Now()}
                        }</span> else<span class="cov0" title="0"> {
                                entry.count++
                                entry.lastFail = time.Now()
                        }</span>
                        <span class="cov1" title="1">a.authFailuresMu.Unlock()

                        a.logger.Errorf("Failed authentication attempt from IP: %s", ip)
                        w.Header().Set("WWW-Authenticate", `Basic realm="Cerberus API"`)
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return</span>
                }

                // On success, reset failure count
                <span class="cov1" title="1">a.authFailuresMu.Lock()
                delete(a.authFailures, ip)
                a.authFailuresMu.Unlock()

                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "errors"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "strings"

        "cerberus/core"
)

var validSeverities = map[string]bool{"Low": true, "Medium": true, "High": true, "Critical": true}

var validOperators = map[string]bool{
        "equals": true, "not_equals": true, "contains": true, "starts_with": true, "ends_with": true,
        "regex": true, "greater_than": true, "less_than": true, "greater_than_or_equal": true, "less_than_or_equal": true,
}

var validLogics = map[string]bool{"AND": true, "OR": true}

// validateRule validates a rule
func validateBaseRule(id, name, description, severity string, version int) error <span class="cov10" title="21">{
        name = strings.TrimSpace(name)
        description = strings.TrimSpace(description)
        severity = strings.TrimSpace(severity)

        if len(name) == 0 || len(name) &gt; 100 </span><span class="cov5" title="4">{
                return errors.New("name is required and must be 1-100 characters")
        }</span>
        <span class="cov9" title="17">if len(description) &gt; 500 </span><span class="cov0" title="0">{
                return errors.New("description must be at most 500 characters")
        }</span>
        <span class="cov9" title="17">if !validSeverities[severity] </span><span class="cov3" title="2">{
                return errors.New("severity must be Low, Medium, High, or Critical")
        }</span>
        <span class="cov9" title="15">if version &lt;= 0 </span><span class="cov1" title="1">{
                return errors.New("version must be positive")
        }</span>
        <span class="cov8" title="14">return nil</span>
}

func validateConditions(conditions []core.Condition) error <span class="cov8" title="14">{
        for i, cond := range conditions </span><span class="cov8" title="14">{
                field := strings.TrimSpace(cond.Field)
                operator := strings.TrimSpace(cond.Operator)
                logic := strings.TrimSpace(cond.Logic)
                if field == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("condition %d: field is required", i)
                }</span>
                <span class="cov8" title="13">if !validOperators[operator] </span><span class="cov1" title="1">{
                        return fmt.Errorf("condition %d: invalid operator", i)
                }</span>
                <span class="cov8" title="12">if cond.Value == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("condition %d: value is required", i)
                }</span>
                <span class="cov8" title="12">if logic != "" &amp;&amp; !validLogics[logic] </span><span class="cov1" title="1">{
                        return fmt.Errorf("condition %d: logic must be AND or OR", i)
                }</span>
        }
        <span class="cov8" title="11">return nil</span>
}

func validateRule(rule *core.Rule) error <span class="cov7" title="9">{
        if err := validateBaseRule(rule.ID, rule.Name, rule.Description, rule.Severity, rule.Version); err != nil </span><span class="cov4" title="3">{
                return err
        }</span>
        <span class="cov6" title="6">if len(rule.Conditions) == 0 </span><span class="cov1" title="1">{
                return errors.New("at least one condition is required")
        }</span>
        <span class="cov5" title="5">if err := validateConditions(rule.Conditions); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="5">for _, action := range rule.Actions </span><span class="cov0" title="0">{
                if err := validateAction(&amp;action); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov5" title="5">return nil</span>
}

func validateWebhookAction(config map[string]interface{}) error <span class="cov7" title="8">{
        urlStr, ok := config["url"].(string)
        if !ok || strings.TrimSpace(urlStr) == "" </span><span class="cov3" title="2">{
                return errors.New("webhook action requires a valid url in config")
        }</span>
        <span class="cov6" title="6">parsedURL, err := url.Parse(urlStr)
        if err != nil || parsedURL.Scheme == "" || parsedURL.Host == "" </span><span class="cov0" title="0">{
                return errors.New("webhook action requires a valid URL")
        }</span>
        <span class="cov6" title="6">if parsedURL.Scheme != "http" &amp;&amp; parsedURL.Scheme != "https" </span><span class="cov1" title="1">{
                return errors.New("webhook URL must use http or https scheme")
        }</span>
        <span class="cov5" title="5">return nil</span>
}

func validateSlackAction(config map[string]interface{}) error <span class="cov3" title="2">{
        if webhookURL, ok := config["webhook_url"].(string); !ok || strings.TrimSpace(webhookURL) == "" </span><span class="cov1" title="1">{
                return errors.New("slack action requires a valid webhook_url in config")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func validateJiraAction(config map[string]interface{}) error <span class="cov4" title="3">{
        if baseURL, ok := config["base_url"].(string); !ok || strings.TrimSpace(baseURL) == "" </span><span class="cov1" title="1">{
                return errors.New("jira action requires a valid base_url in config")
        }</span>
        <span class="cov3" title="2">if project, ok := config["project"].(string); !ok || strings.TrimSpace(project) == "" </span><span class="cov1" title="1">{
                return errors.New("jira action requires a valid project in config")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func validateEmailAction(config map[string]interface{}) error <span class="cov3" title="2">{
        if smtpServer, ok := config["smtp_server"].(string); !ok || strings.TrimSpace(smtpServer) == "" </span><span class="cov0" title="0">{
                return errors.New("email action requires a valid smtp_server in config")
        }</span>
        <span class="cov3" title="2">var portVal float64
        if p, ok := config["port"].(float64); ok </span><span class="cov0" title="0">{
                portVal = p
        }</span> else<span class="cov3" title="2"> if p, ok := config["port"].(int); ok </span><span class="cov3" title="2">{
                portVal = float64(p)
        }</span> else<span class="cov0" title="0"> {
                return errors.New("email action requires a valid port (1-65535) in config")
        }</span>
        <span class="cov3" title="2">if portVal &lt; 1 || portVal &gt; 65535 || portVal != float64(int(portVal)) </span><span class="cov1" title="1">{
                return errors.New("email action requires a valid port (1-65535) in config")
        }</span>
        <span class="cov1" title="1">if from, ok := config["from"].(string); !ok || strings.TrimSpace(from) == "" </span><span class="cov0" title="0">{
                return errors.New("email action requires a valid from in config")
        }</span>
        <span class="cov1" title="1">if to, ok := config["to"].(string); !ok || strings.TrimSpace(to) == "" </span><span class="cov0" title="0">{
                return errors.New("email action requires a valid to in config")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// getRealIP extracts the real client IP, considering proxy headers if trusted
func getRealIP(r *http.Request, trustProxy bool) string <span class="cov6" title="7">{
        // Check X-Forwarded-For header if proxy headers are trusted
        if trustProxy </span><span class="cov1" title="1">{
                if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov1" title="1">{
                        // Take the first IP in case of multiple
                        ips := strings.Split(xff, ",")
                        if len(ips) &gt; 0 </span><span class="cov1" title="1">{
                                ip := strings.TrimSpace(ips[0])
                                if ip != "" &amp;&amp; net.ParseIP(ip) != nil </span><span class="cov1" title="1">{
                                        return ip
                                }</span>
                        }
                }
                // Check X-Real-IP header
                <span class="cov0" title="0">if xri := r.Header.Get("X-Real-IP"); xri != "" &amp;&amp; net.ParseIP(xri) != nil </span><span class="cov0" title="0">{
                        return xri
                }</span>
        }
        // Fallback to RemoteAddr
        <span class="cov6" title="6">host, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil </span><span class="cov0" title="0">{
                return r.RemoteAddr
        }</span>
        <span class="cov6" title="6">return host</span>
}

func validateAction(action *core.Action) error <span class="cov6" title="6">{
        atype := strings.TrimSpace(action.Type)
        validTypes := map[string]bool{"webhook": true, "jira": true, "email": true, "slack": true}
        if atype == "" </span><span class="cov0" title="0">{
                return errors.New("action type is required")
        }</span>
        <span class="cov6" title="6">if !validTypes[atype] </span><span class="cov1" title="1">{
                return errors.New("action type must be webhook, jira, email, or slack")
        }</span>
        <span class="cov5" title="5">switch atype </span>{
        case "webhook":<span class="cov5" title="5">
                return validateWebhookAction(action.Config)</span>
        case "jira":<span class="cov0" title="0">
                return validateJiraAction(action.Config)</span>
        case "email":<span class="cov0" title="0">
                return validateEmailAction(action.Config)</span>
        case "slack":<span class="cov0" title="0">
                return validateSlackAction(action.Config)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateCorrelationRule validates a correlation rule
func validateCorrelationRule(rule *core.CorrelationRule) error <span class="cov7" title="8">{
        if err := validateBaseRule(rule.ID, rule.Name, rule.Description, rule.Severity, rule.Version); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("correlation rule: %w", err)
        }</span>
        <span class="cov6" title="7">if rule.Window &lt;= 0 </span><span class="cov1" title="1">{
                return errors.New("correlation rule window must be positive")
        }</span>
        <span class="cov6" title="6">if len(rule.Conditions) == 0 </span><span class="cov0" title="0">{
                return errors.New("at least one condition is required")
        }</span>
        <span class="cov6" title="6">if len(rule.Sequence) == 0 </span><span class="cov1" title="1">{
                return errors.New("sequence is required")
        }</span>
        <span class="cov5" title="5">if err := validateConditions(rule.Conditions); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="5">for _, action := range rule.Actions </span><span class="cov0" title="0">{
                if err := validateAction(&amp;action); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov5" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/viper"
        "golang.org/x/crypto/bcrypt"
)

// Config holds all configuration for the Cerberus service
type Config struct {
        MongoDB struct {
                URI                string `mapstructure:"uri"`
                Database           string `mapstructure:"database"`
                Enabled            bool   `mapstructure:"enabled"`
                BatchInsertTimeout int    `mapstructure:"batch_insert_timeout"` // seconds
                MaxPoolSize        uint64 `mapstructure:"max_pool_size"`
        } `mapstructure:"mongodb"`

        Listeners struct {
                Syslog struct {
                        Port int    `mapstructure:"port"`
                        Host string `mapstructure:"host"`
                } `mapstructure:"syslog"`
                CEF struct {
                        Port int    `mapstructure:"port"`
                        Host string `mapstructure:"host"`
                } `mapstructure:"cef"`
                JSON struct {
                        Port     int    `mapstructure:"port"`
                        Host     string `mapstructure:"host"`
                        TLS      bool   `mapstructure:"tls"`
                        CertFile string `mapstructure:"cert_file"`
                        KeyFile  string `mapstructure:"key_file"`
                } `mapstructure:"json"`
                SkipOnError bool `mapstructure:"skip_on_error"`
        } `mapstructure:"listeners"`

        API struct {
                Version        string   `mapstructure:"version"`
                Port           int      `mapstructure:"port"`
                TLS            bool     `mapstructure:"tls"`
                CertFile       string   `mapstructure:"cert_file"`
                KeyFile        string   `mapstructure:"key_file"`
                AllowedOrigins []string `mapstructure:"allowed_origins"`
                TrustProxy     bool     `mapstructure:"trust_proxy"`
                RateLimit      struct {
                        RequestsPerSecond int `mapstructure:"requests_per_second"`
                        Burst             int `mapstructure:"burst"`
                } `mapstructure:"rate_limit"`
        } `mapstructure:"api"`

        Auth struct {
                Enabled        bool   `mapstructure:"enabled"`
                Username       string `mapstructure:"username"`
                Password       string `mapstructure:"password"`
                HashedPassword string
                BcryptCost     int `mapstructure:"bcrypt_cost"`
        } `mapstructure:"auth"`

        Rules struct {
                File string `mapstructure:"file"`
        } `mapstructure:"rules"`

        CorrelationRules struct {
                File string `mapstructure:"file"`
        } `mapstructure:"correlation_rules"`

        Retention struct {
                Events int `mapstructure:"events"` // days
                Alerts int `mapstructure:"alerts"` // days
        } `mapstructure:"retention"`

        Storage struct {
                Deduplication     bool `mapstructure:"deduplication"`
                DedupCacheSize    int  `mapstructure:"dedup_cache_size"`
                DedupEvictionSize int  `mapstructure:"dedup_eviction_size"`
                BufferSize        int  `mapstructure:"buffer_size"`
        } `mapstructure:"storage"`

        Engine struct {
                ChannelBufferSize   int `mapstructure:"channel_buffer_size"`
                WorkerCount         int `mapstructure:"worker_count"`
                ActionWorkerCount   int `mapstructure:"action_worker_count"`
                RateLimit           int `mapstructure:"rate_limit"`
                CorrelationStateTTL int `mapstructure:"correlation_state_ttl"` // seconds
                ActionTimeout       int `mapstructure:"action_timeout"`        // seconds
        } `mapstructure:"engine"`
}

// setDefaults sets default configuration values
func setDefaults() <span class="cov1" title="1">{
        viper.SetDefault("mongodb.uri", "mongodb://localhost:27017")
        viper.SetDefault("mongodb.database", "cerberus")
        viper.SetDefault("mongodb.enabled", true)
        viper.SetDefault("mongodb.batch_insert_timeout", 5)
        viper.SetDefault("mongodb.max_pool_size", 10)
        viper.SetDefault("listeners.syslog.port", 514)
        viper.SetDefault("listeners.syslog.host", "0.0.0.0")
        viper.SetDefault("listeners.cef.port", 515)
        viper.SetDefault("listeners.cef.host", "0.0.0.0")
        viper.SetDefault("listeners.json.port", 8080)
        viper.SetDefault("listeners.json.host", "0.0.0.0")
        viper.SetDefault("listeners.json.tls", true)
        viper.SetDefault("listeners.json.cert_file", "server.crt")
        viper.SetDefault("listeners.json.key_file", "server.key")
        viper.SetDefault("api.version", "v1")
        viper.SetDefault("api.port", 8081)
        viper.SetDefault("api.tls", true)
        viper.SetDefault("api.cert_file", "server.crt")
        viper.SetDefault("api.key_file", "server.key")
        viper.SetDefault("api.allowed_origins", []string{"http://localhost:3000", "https://localhost:3000"})
        viper.SetDefault("api.trust_proxy", false)
        viper.SetDefault("api.rate_limit.burst", 10)
        viper.SetDefault("auth.bcrypt_cost", 10)
        viper.SetDefault("rules.file", "rules.json")
        viper.SetDefault("correlation_rules.file", "correlation_rules.json")
        viper.SetDefault("retention.events", 30)
        viper.SetDefault("retention.alerts", 30)
        viper.SetDefault("storage.dedup_cache_size", 10000)
        viper.SetDefault("storage.deduplication", true)
        viper.SetDefault("storage.dedup_eviction_size", 1000)
        viper.SetDefault("storage.buffer_size", 100)
        viper.SetDefault("engine.channel_buffer_size", 1000)
        viper.SetDefault("engine.worker_count", 4)
        viper.SetDefault("engine.action_worker_count", 5)
        viper.SetDefault("engine.rate_limit", 1000)
        viper.SetDefault("engine.correlation_state_ttl", 3600) // 1 hour
        viper.SetDefault("engine.action_timeout", 10)          // seconds
}</span>

// loadFromEnv sets up environment variable loading
func loadFromEnv() <span class="cov1" title="1">{
        viper.SetEnvPrefix("CERBERUS")
        viper.AutomaticEnv()
}</span>

// validateAndHash validates and hashes the password
func validateAndHash(config *Config) error <span class="cov2" title="2">{
        // Hash the password if provided
        if config.Auth.Password != "" </span><span class="cov1" title="1">{
                hashed, err := bcrypt.GenerateFromPassword([]byte(config.Auth.Password), config.Auth.BcryptCost)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to hash password: %w", err)
                }</span>
                <span class="cov1" title="1">config.Auth.HashedPassword = string(hashed)
                config.Auth.Password = ""</span> // clear plain password
        }

        <span class="cov2" title="2">if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// LoadConfig loads configuration from file and environment variables
func LoadConfig() (*Config, error) <span class="cov1" title="1">{
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(".")
        viper.AddConfigPath("./config")

        setDefaults()
        loadFromEnv()

        if err := viper.ReadInConfig(); err != nil </span>{<span class="cov1" title="1">
                // Config file not found, will use defaults and env vars
        }</span>

        <span class="cov1" title="1">var config Config
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to decode config: %w", err)
        }</span>

        // Adjust relative paths to be relative to the current working directory
        <span class="cov1" title="1">if config.Rules.File != "" &amp;&amp; !filepath.IsAbs(config.Rules.File) </span><span class="cov1" title="1">{
                config.Rules.File = filepath.Join(".", config.Rules.File)
        }</span>
        <span class="cov1" title="1">if config.CorrelationRules.File != "" &amp;&amp; !filepath.IsAbs(config.CorrelationRules.File) </span><span class="cov1" title="1">{
                config.CorrelationRules.File = filepath.Join(".", config.CorrelationRules.File)
        }</span>

        <span class="cov1" title="1">if err := validateAndHash(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;config, nil</span>
}

// validateConfig validates the configuration for security and correctness
func validateConfig(config *Config) error <span class="cov8" title="18">{
        // Validate MongoDB URI
        if config.MongoDB.Enabled </span><span class="cov7" title="13">{
                if !strings.HasPrefix(config.MongoDB.URI, "mongodb://") &amp;&amp; !strings.HasPrefix(config.MongoDB.URI, "mongodb+srv://") </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid MongoDB URI: must start with mongodb:// or mongodb+srv://")
                }</span>
                <span class="cov7" title="12">parsed, err := url.Parse(config.MongoDB.URI)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid MongoDB URI: %w", err)
                }</span>
                <span class="cov7" title="12">if parsed.Host == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid MongoDB URI: missing host")
                }</span>
                <span class="cov6" title="11">if config.MongoDB.Database == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("MongoDB database cannot be empty")
                }</span>
        }

        // Validate listener ports and hosts
        <span class="cov7" title="15">listeners := []struct {
                name string
                port int
                host string
        }{
                {"syslog", config.Listeners.Syslog.Port, config.Listeners.Syslog.Host},
                {"cef", config.Listeners.CEF.Port, config.Listeners.CEF.Host},
                {"json", config.Listeners.JSON.Port, config.Listeners.JSON.Host},
        }

        for _, l := range listeners </span><span class="cov10" title="41">{
                if l.port &lt; 1 || l.port &gt; 65535 </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid %s port: %d (must be 1-65535)", l.name, l.port)
                }</span>
                <span class="cov9" title="40">if l.host == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid %s host: host cannot be empty", l.name)
                }</span>
        }

        // Validate API port
        <span class="cov7" title="13">if config.API.Port &lt; 1 || config.API.Port &gt; 65535 </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid API port: %d (must be 1-65535)", config.API.Port)
        }</span>

        // Validate retention
        <span class="cov7" title="12">if config.Retention.Events &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("retention events must be positive")
        }</span>
        <span class="cov6" title="11">if config.Retention.Alerts &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("retention alerts must be positive")
        }</span>

        // Validate auth
        <span class="cov6" title="10">if config.Auth.Enabled &amp;&amp; config.Auth.HashedPassword == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("authentication enabled but no password set")
        }</span>
        <span class="cov6" title="9">if config.Auth.Enabled &amp;&amp; config.Auth.Username == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("username cannot be empty when auth is enabled")
        }</span>

        // Validate rules file (basic check) only if MongoDB is disabled
        <span class="cov6" title="8">if !config.MongoDB.Enabled </span><span class="cov4" title="5">{
                if config.Rules.File == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("rules file cannot be empty")
                }</span>
                <span class="cov4" title="4">if !strings.HasSuffix(config.Rules.File, ".json") &amp;&amp; !strings.HasSuffix(config.Rules.File, ".yaml") &amp;&amp; !strings.HasSuffix(config.Rules.File, ".yml") </span><span class="cov1" title="1">{
                        return fmt.Errorf("rules file must be a JSON or YAML file")
                }</span>
                <span class="cov3" title="3">if _, err := os.Stat(config.Rules.File); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return fmt.Errorf("rules file does not exist")
                }</span>
        }

        // Validate correlation rules file (basic check) only if MongoDB is disabled
        <span class="cov4" title="5">if !config.MongoDB.Enabled &amp;&amp; config.CorrelationRules.File != "" </span><span class="cov2" title="2">{
                if !strings.HasSuffix(config.CorrelationRules.File, ".json") &amp;&amp; !strings.HasSuffix(config.CorrelationRules.File, ".yaml") &amp;&amp; !strings.HasSuffix(config.CorrelationRules.File, ".yml") </span><span class="cov1" title="1">{
                        return fmt.Errorf("correlation rules file must be a JSON or YAML file")
                }</span>
                <span class="cov1" title="1">if _, err := os.Stat(config.CorrelationRules.File); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return fmt.Errorf("correlation rules file does not exist")
                }</span>
        }

        <span class="cov3" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package core

import (
        "time"

        "github.com/google/uuid"
)

// Alert represents a security alert generated by rule matches
type Alert struct {
        AlertID      string    `json:"alert_id" bson:"alert_id" example:"alert-123"`
        RuleID       string    `json:"rule_id" bson:"rule_id" example:"failed_login"`
        EventID      string    `json:"event_id" bson:"event_id" example:"event-456"`
        Timestamp    time.Time `json:"timestamp" bson:"timestamp" swaggertype:"string" example:"2023-10-31T12:00:00Z"`
        Severity     string    `json:"severity" bson:"severity" example:"Warning"`
        Status       string    `json:"status" bson:"status" example:"New"` // New, In Progress, Closed
        JiraTicketID string    `json:"jira_ticket_id,omitempty" bson:"jira_ticket_id,omitempty" example:"PROJ-123"`
        Event        *Event    `json:"event" bson:"event"`
}

// NewAlert creates a new Alert with a generated UUID
func NewAlert(ruleID, eventID string, severity string, event *Event) *Alert <span class="cov8" title="1">{
        return &amp;Alert{
                AlertID:   uuid.New().String(),
                RuleID:    ruleID,
                EventID:   eventID,
                Timestamp: time.Now().UTC(),
                Severity:  severity,
                Status:    "New",
                Event:     event,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package core

import (
        "regexp"
        "time"
)

// AlertableRule interface for rules that can generate alerts
type AlertableRule interface {
        GetID() string
        GetSeverity() string
        GetActions() []Action
}

// Rule represents a detection rule
type Rule struct {
        ID          string      `json:"id" bson:"_id" example:"failed_login"`
        Name        string      `json:"name" bson:"name" example:"Failed User Login"`
        Description string      `json:"description" bson:"description" example:"Detects multiple failed login attempts"`
        Severity    string      `json:"severity" bson:"severity" example:"Warning"`
        Version     int         `json:"version" bson:"version" example:"1"`
        Conditions  []Condition `json:"conditions" bson:"conditions"`
        Actions     []Action    `json:"actions" bson:"actions"`
        Enabled     bool        `json:"enabled" bson:"enabled" example:"true"`
}

// GetID returns the rule ID
func (r Rule) GetID() string <span class="cov8" title="1">{
        return r.ID
}</span>

// GetSeverity returns the rule severity
func (r Rule) GetSeverity() string <span class="cov8" title="1">{
        return r.Severity
}</span>

// GetActions returns the rule actions
func (r Rule) GetActions() []Action <span class="cov8" title="1">{
        return r.Actions
}</span>

// Condition represents a match condition
type Condition struct {
        Field    string         `json:"field" bson:"field" example:"fields.status"`
        Operator string         `json:"operator" bson:"operator" example:"equals"` // equals, not_equals, contains, starts_with, ends_with, regex, greater_than, less_than, greater_than_or_equal, less_than_or_equal
        Value    interface{}    `json:"value" bson:"value" example:"failure"`
        Logic    string         `json:"logic" bson:"logic" example:"AND"` // AND, OR (for combining conditions)
        Regex    *regexp.Regexp `json:"-"`                                // Compiled regex for regex operator
}

// Action represents an action to take on match (for Phase 3, but include)
type Action struct {
        ID     string                 `json:"id" bson:"_id" example:"action-123"`
        Type   string                 `json:"type" bson:"type" example:"webhook"` // webhook, jira, etc.
        Config map[string]interface{} `json:"config" bson:"config" example:"{\"url\":\"https://example.com/webhook\"}"`
}

// Rules is a collection of rules
type Rules struct {
        Rules []Rule `json:"rules" bson:"rules"`
}

// CorrelationRules is a collection of correlation rules
type CorrelationRules struct {
        Rules []CorrelationRule `json:"rules" bson:"rules"`
}

// CorrelationRule for multi-event rules
type CorrelationRule struct {
        ID          string        `json:"id" bson:"_id" example:"correlation_rule_1"`
        Name        string        `json:"name" bson:"name" example:"Brute Force Detection"`
        Description string        `json:"description" bson:"description" example:"Detects multiple failed logins"`
        Severity    string        `json:"severity" bson:"severity" example:"High"`
        Version     int           `json:"version" bson:"version" example:"1"`
        Window      time.Duration `json:"window" bson:"window" swaggertype:"integer" example:"300000000000"` // time window for correlation in nanoseconds
        Conditions  []Condition   `json:"conditions" bson:"conditions"`
        Sequence    []string      `json:"sequence" bson:"sequence" example:"user_login,user_login,user_login"` // sequence of event types
        Actions     []Action      `json:"actions" bson:"actions"`
}

// GetID returns the correlation rule ID
func (cr CorrelationRule) GetID() string <span class="cov8" title="1">{
        return cr.ID
}</span>

// GetSeverity returns the correlation rule severity
func (cr CorrelationRule) GetSeverity() string <span class="cov8" title="1">{
        return cr.Severity
}</span>

// GetActions returns the correlation rule actions
func (cr CorrelationRule) GetActions() []Action <span class="cov8" title="1">{
        return cr.Actions
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package core

import (
        "time"

        "github.com/google/uuid"
)

// Event represents the common event schema for all ingested security events
type Event struct {
        EventID      string                 `json:"event_id" bson:"event_id" example:"event-123"`
        Timestamp    time.Time              `json:"timestamp" bson:"timestamp" swaggertype:"string" example:"2023-10-31T12:00:00Z"`
        SourceFormat string                 `json:"source_format" bson:"source_format" example:"json"`
        SourceIP     string                 `json:"source_ip" bson:"source_ip" example:"192.168.1.100"`
        EventType    string                 `json:"event_type" bson:"event_type" example:"user_login"`
        Severity     string                 `json:"severity" bson:"severity" example:"info"`
        RawData      string                 `json:"raw_data" bson:"raw_data" example:"raw log data"`
        Fields       map[string]interface{} `json:"fields" bson:"fields" example:"{\"status\":\"failure\",\"user\":\"testuser\"}"`
}

// NewEvent creates a new Event with a generated UUID
func NewEvent() *Event <span class="cov10" title="2">{
        return &amp;Event{
                EventID:   uuid.New().String(),
                Timestamp: time.Now().UTC(),
                Fields:    make(map[string]interface{}),
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package detect

import (
        "bytes"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/smtp"
        "os"
        "time"

        "cerberus/core"
        "cerberus/metrics"
        "go.uber.org/zap"
)

// ActionExecutor handles executing response actions
type ActionExecutor struct {
        httpClient *http.Client
        logger     *zap.SugaredLogger
}

const maxRetries = 3

// NewActionExecutor creates a new action executor
func NewActionExecutor(timeout time.Duration, logger *zap.SugaredLogger) *ActionExecutor <span class="cov10" title="26">{
        return &amp;ActionExecutor{
                httpClient: &amp;http.Client{Timeout: timeout},
                logger:     logger,
        }
}</span>

// retryExecute executes a function with retry logic
func (ae *ActionExecutor) retryExecute(executeFunc func() error, successFormat string, successArgs []interface{}, actionType string) error <span class="cov7" title="12">{
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov9" title="22">{
                err := executeFunc()
                if err == nil </span><span class="cov6" title="7">{
                        ae.logger.Infof(successFormat, successArgs...)
                        metrics.ActionsExecuted.WithLabelValues(actionType).Inc()
                        return nil
                }</span>
                <span class="cov8" title="15">ae.logger.Warnf("Action failed (attempt %d/%d): %v", i+1, maxRetries, err)
                if i &lt; maxRetries-1 </span><span class="cov7" title="10">{
                        backoff := time.Duration(1&lt;&lt;uint(i)) * time.Second
                        if backoff &gt; 30*time.Second </span><span class="cov0" title="0">{
                                backoff = 30 * time.Second
                        }</span>
                        <span class="cov7" title="10">time.Sleep(backoff)</span>
                }
        }
        <span class="cov5" title="5">return fmt.Errorf("action failed after %d retries", maxRetries)</span>
}

// ExecuteActions executes all actions for a rule match
func (ae *ActionExecutor) ExecuteActions(rule core.AlertableRule, alert *core.Alert) error <span class="cov7" title="9">{
        var errs []error
        for _, action := range rule.GetActions() </span><span class="cov6" title="7">{
                if action.Config == nil </span><span class="cov1" title="1">{
                        errs = append(errs, fmt.Errorf("action config is nil for type %s", action.Type))
                        continue</span>
                }
                <span class="cov5" title="6">switch action.Type </span>{
                case "webhook":<span class="cov4" title="3">
                        if err := ae.executeWebhook(action, alert); err != nil </span><span class="cov1" title="1">{
                                ae.logger.Errorf("Error executing webhook action: %v", err)
                                errs = append(errs, fmt.Errorf("webhook action failed: %w", err))
                        }</span>
                case "jira":<span class="cov0" title="0">
                        if err := ae.executeJira(action, alert); err != nil </span><span class="cov0" title="0">{
                                ae.logger.Errorf("Error executing jira action: %v", err)
                                errs = append(errs, fmt.Errorf("jira action failed: %w", err))
                        }</span>
                case "slack":<span class="cov1" title="1">
                        if err := ae.executeSlack(action, alert); err != nil </span><span class="cov0" title="0">{
                                ae.logger.Errorf("Error executing slack action: %v", err)
                                errs = append(errs, fmt.Errorf("slack action failed: %w", err))
                        }</span>
                case "email":<span class="cov0" title="0">
                        if err := ae.executeEmail(action, alert); err != nil </span><span class="cov0" title="0">{
                                ae.logger.Errorf("Error executing email action: %v", err)
                                errs = append(errs, fmt.Errorf("email action failed: %w", err))
                        }</span>
                default:<span class="cov2" title="2">
                        ae.logger.Errorf("Unknown action type: %s", action.Type)
                        errs = append(errs, fmt.Errorf("unknown action type: %s", action.Type))</span>
                }
        }
        <span class="cov7" title="9">if len(errs) &gt; 0 </span><span class="cov4" title="3">{
                return fmt.Errorf("one or more actions failed: %v", errs)
        }</span>
        <span class="cov5" title="6">return nil</span>
}

// executeWebhook executes a webhook action with retry logic
func (ae *ActionExecutor) executeWebhook(action core.Action, alert *core.Alert) error <span class="cov5" title="5">{
        url, ok := action.Config["url"].(string)
        if !ok </span><span class="cov0" title="0">{
                ae.logger.Warnf("Webhook URL not found in config")
                return fmt.Errorf("webhook URL not found in config")
        }</span>

        <span class="cov5" title="5">payload, err := json.Marshal(alert)
        if err != nil </span><span class="cov0" title="0">{
                ae.logger.Errorf("Failed to marshal alert: %v", err)
                return fmt.Errorf("failed to marshal alert: %w", err)
        }</span>

        <span class="cov5" title="5">return ae.retryExecute(func() error </span><span class="cov7" title="9">{ return ae.sendWebhook(url, payload) }</span>, "Webhook sent successfully to %s", []interface{}{url}, "webhook")
}

// sendWebhook sends the HTTP POST request
func (ae *ActionExecutor) sendWebhook(url string, payload []byte) error <span class="cov7" title="11">{
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="11">req.Header.Set("Content-Type", "application/json")

        resp, err := ae.httpClient.Do(req)

        if err != nil </span><span class="cov5" title="6">{
                return err
        }</span>

        <span class="cov5" title="5">defer func(Body io.ReadCloser) </span><span class="cov5" title="5">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ae.logger.Errorf("Failed to close response body: %v", err)
                }</span>
        }(resp.Body)

        <span class="cov5" title="5">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("webhook returned status %d", resp.StatusCode)
        }</span>
        <span class="cov5" title="5">return nil</span>
}

// executeJira creates a Jira ticket for the alert
func (ae *ActionExecutor) executeJira(action core.Action, alert *core.Alert) error <span class="cov4" title="4">{
        baseURL, ok := action.Config["base_url"].(string)
        if !ok </span><span class="cov1" title="1">{
                ae.logger.Warnf("Jira base URL not found in config")
                return fmt.Errorf("Jira base URL not found in config")
        }</span>
        <span class="cov4" title="3">username := os.Getenv("CERBERUS_JIRA_USERNAME")
        if username == "" </span><span class="cov1" title="1">{
                ae.logger.Warnf("Jira username not set in environment")
                return fmt.Errorf("Jira username not set in environment")
        }</span>
        <span class="cov2" title="2">token := os.Getenv("CERBERUS_JIRA_TOKEN")
        if token == "" </span><span class="cov0" title="0">{
                ae.logger.Warnf("Jira token not set in environment")
                return fmt.Errorf("Jira token not set in environment")
        }</span>
        <span class="cov2" title="2">project, ok := action.Config["project"].(string)
        if !ok </span><span class="cov0" title="0">{
                ae.logger.Warnf("Jira project not found in config")
                return fmt.Errorf("Jira project not found in config")
        }</span>

        // Create issue payload
        <span class="cov2" title="2">issue := map[string]interface{}{
                "fields": map[string]interface{}{
                        "project":     map[string]string{"key": project},
                        "summary":     fmt.Sprintf("Alert: %s", alert.AlertID),
                        "description": fmt.Sprintf("Severity: %s\nEvent ID: %s\nRaw Data: %s", alert.Severity, alert.EventID, alert.Event.RawData),
                        "issuetype":   map[string]string{"name": "Task"},
                },
        }

        payload, err := json.Marshal(issue)
        if err != nil </span><span class="cov0" title="0">{
                ae.logger.Errorf("Failed to marshal Jira issue: %v", err)
                return fmt.Errorf("failed to marshal Jira issue: %w", err)
        }</span>

        <span class="cov2" title="2">return ae.retryExecute(func() error </span><span class="cov4" title="4">{ return ae.sendJiraRequest(baseURL, username, token, payload) }</span>, "Jira ticket created successfully for alert %s", []interface{}{alert.AlertID}, "jira")
}

// sendJiraRequest sends the Jira API request
func (ae *ActionExecutor) sendJiraRequest(baseURL, username, token string, payload []byte) error <span class="cov4" title="4">{
        url := fmt.Sprintf("%s/rest/api/2/issue", baseURL)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="4">req.Header.Set("Content-Type", "application/json")
        req.SetBasicAuth(username, token)

        resp, err := ae.httpClient.Do(req)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="4">defer func(Body io.ReadCloser) </span><span class="cov4" title="4">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ae.logger.Errorf("Failed to close response body: %v", err)
                }</span>
        }(resp.Body)

        <span class="cov4" title="4">if resp.StatusCode != 201 </span><span class="cov4" title="3">{
                return fmt.Errorf("Jira API returned status %d", resp.StatusCode)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// executeSlack sends a message to a Slack channel
func (ae *ActionExecutor) executeSlack(action core.Action, alert *core.Alert) error <span class="cov2" title="2">{
        webhookURL, ok := action.Config["webhook_url"].(string)
        if !ok </span><span class="cov0" title="0">{
                ae.logger.Warnf("Slack webhook URL not found in config")
                return fmt.Errorf("Slack webhook URL not found in config")
        }</span>

        <span class="cov2" title="2">message := map[string]string{
                "text": fmt.Sprintf("Alert: %s\nSeverity: %s\nEvent ID: %s\nRule: %s", alert.AlertID, alert.Severity, alert.EventID, alert.RuleID),
        }

        payload, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                ae.logger.Errorf("Failed to marshal Slack message: %v", err)
                return fmt.Errorf("failed to marshal Slack message: %w", err)
        }</span>

        <span class="cov2" title="2">return ae.retryExecute(func() error </span><span class="cov2" title="2">{ return ae.sendWebhook(webhookURL, payload) }</span>, "Slack message sent successfully for alert %s", []interface{}{alert.AlertID}, "slack")
}

// executeEmail sends an email notification
func (ae *ActionExecutor) executeEmail(action core.Action, alert *core.Alert) error <span class="cov4" title="4">{
        smtpServer, ok := action.Config["smtp_server"].(string)
        if !ok </span><span class="cov1" title="1">{
                ae.logger.Warnf("SMTP server not found in config")
                return fmt.Errorf("SMTP server not found in config")
        }</span>
        <span class="cov4" title="3">portFloat, ok := action.Config["port"].(float64)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("SMTP port not found in config")
        }</span>
        <span class="cov2" title="2">if portFloat != float64(int(portFloat)) </span><span class="cov0" title="0">{
                return fmt.Errorf("SMTP port must be an integer")
        }</span>
        <span class="cov2" title="2">port := int(portFloat)
        username := os.Getenv("CERBERUS_SMTP_USERNAME")
        if username == "" </span><span class="cov1" title="1">{
                ae.logger.Warnf("SMTP username not set in environment")
                return fmt.Errorf("SMTP username not set in environment")
        }</span>
        <span class="cov1" title="1">password := os.Getenv("CERBERUS_SMTP_PASSWORD")
        if password == "" </span><span class="cov0" title="0">{
                ae.logger.Warnf("SMTP password not set in environment")
                return fmt.Errorf("SMTP password not set in environment")
        }</span>
        <span class="cov1" title="1">from, ok := action.Config["from"].(string)
        if !ok </span><span class="cov0" title="0">{
                ae.logger.Warnf("From email not found in config")
                return fmt.Errorf("From email not found in config")
        }</span>
        <span class="cov1" title="1">to, ok := action.Config["to"].(string)
        if !ok </span><span class="cov0" title="0">{
                ae.logger.Warnf("To email not found in config")
                return fmt.Errorf("To email not found in config")
        }</span>

        <span class="cov1" title="1">subject := fmt.Sprintf("Alert: %s", alert.AlertID)
        body := fmt.Sprintf("Severity: %s\nEvent ID: %s\nRule: %s\nRaw Data: %s", alert.Severity, alert.EventID, alert.RuleID, alert.Event.RawData)

        msg := fmt.Sprintf("From: %s\r\nTo: %s\r\nSubject: %s\r\n\r\n%s", from, to, subject, body)

        auth := smtp.PlainAuth("", username, password, smtpServer)

        sendFunc := func() error </span><span class="cov4" title="3">{
                client, err := smtp.Dial(fmt.Sprintf("%s:%d", smtpServer, int(port)))
                if err != nil </span><span class="cov4" title="3">{
                        return fmt.Errorf("failed to dial SMTP server: %w", err)
                }</span>
                <span class="cov0" title="0">defer client.Close()

                // Enforce TLS if STARTTLS is supported
                if ok, _ := client.Extension("STARTTLS"); ok </span><span class="cov0" title="0">{
                        config := &amp;tls.Config{ServerName: smtpServer}
                        if err = client.StartTLS(config); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to start TLS: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">if err = client.Auth(auth); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to authenticate: %w", err)
                }</span>

                <span class="cov0" title="0">if err = client.Mail(from); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set sender: %w", err)
                }</span>

                <span class="cov0" title="0">if err = client.Rcpt(to); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set recipient: %w", err)
                }</span>

                <span class="cov0" title="0">w, err := client.Data()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start data: %w", err)
                }</span>

                <span class="cov0" title="0">_, err = w.Write([]byte(msg))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write message: %w", err)
                }</span>

                <span class="cov0" title="0">err = w.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close data: %w", err)
                }</span>

                <span class="cov0" title="0">return client.Quit()</span>
        }

        <span class="cov1" title="1">return ae.retryExecute(sendFunc, "Email sent successfully for alert %s", []interface{}{alert.AlertID}, "email")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package detect

import (
        "sync"
        "time"

        "cerberus/config"
        "cerberus/core"
        "cerberus/metrics"
        "go.uber.org/zap"
)

// Detector runs the rule engine on events
type Detector struct {
        engine            *RuleEngine
        inputEventCh      &lt;-chan *core.Event
        outputEventCh     chan&lt;- *core.Event
        alertCh           chan&lt;- *core.Alert
        actionExec        *ActionExecutor
        actionCh          chan func()
        actionWorkerCount int
        wg                sync.WaitGroup
        logger            *zap.SugaredLogger
}

// NewDetector creates a new detector
func NewDetector(engine *RuleEngine, inputEventCh &lt;-chan *core.Event, outputEventCh chan&lt;- *core.Event, alertCh chan&lt;- *core.Alert, cfg *config.Config, logger *zap.SugaredLogger) *Detector <span class="cov8" title="7">{
        return &amp;Detector{
                engine:            engine,
                inputEventCh:      inputEventCh,
                outputEventCh:     outputEventCh,
                alertCh:           alertCh,
                actionExec:        NewActionExecutor(time.Duration(cfg.Engine.ActionTimeout)*time.Second, logger),
                actionCh:          make(chan func(), 100), // buffer for action tasks
                actionWorkerCount: cfg.Engine.ActionWorkerCount,
                logger:            logger,
        }
}</span>

// Start starts the detector
func (d *Detector) Start() <span class="cov6" title="4">{
        d.wg.Add(1)
        go d.run()
        // Start action workers
        for i := 0; i &lt; d.actionWorkerCount; i++ </span><span class="cov6" title="4">{
                d.wg.Add(1)
                go d.actionWorker()
        }</span>
}

// actionWorker processes action tasks
func (d *Detector) actionWorker() <span class="cov6" title="4">{
        defer d.wg.Done()
        for task := range d.actionCh </span><span class="cov6" title="4">{
                task()
        }</span>
}

// processRuleMatches processes matching rules and sends alerts
func (d *Detector) processRuleMatches(rules []core.AlertableRule, event *core.Event) <span class="cov10" title="11">{
        for _, rule := range rules </span><span class="cov7" title="6">{
                alert := core.NewAlert(rule.GetID(), event.EventID, rule.GetSeverity(), event)
                metrics.AlertsGenerated.WithLabelValues(alert.Severity).Inc()
                select </span>{
                case d.alertCh &lt;- alert:<span class="cov7" title="5">
                        // Execute actions asynchronously via worker pool
                        select </span>{
                        case d.actionCh &lt;- func() <span class="cov6" title="4">{
                                defer func() </span><span class="cov6" title="4">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                d.logger.Errorf("Panic in action execution: %v", r)
                                        }</span>
                                }()
                                <span class="cov6" title="4">if err := d.actionExec.ExecuteActions(rule, alert); err != nil </span><span class="cov0" title="0">{
                                        d.logger.Errorf("Action execution failed: %v", err)
                                }</span>
                        }:<span class="cov6" title="4"></span>
                        default:<span class="cov1" title="1">
                                d.logger.Warn("Action queue full, dropping action")</span>
                        }
                default:<span class="cov1" title="1">
                        d.logger.Warnf("Dropped alert for rule %s due to full alert channel", rule.GetID())</span>
                }
        }
}

// run processes events
func (d *Detector) run() <span class="cov6" title="4">{
        defer d.wg.Done()
        defer close(d.actionCh)
        for event := range d.inputEventCh </span><span class="cov6" title="4">{
                start := time.Now()
                matchingRules := d.engine.Evaluate(event)
                matchingCorrelationRules := d.engine.EvaluateCorrelation(event)
                metrics.EventProcessingDuration.Observe(time.Since(start).Seconds())
                d.processRuleMatches(matchingRules, event)
                d.processRuleMatches(matchingCorrelationRules, event)
                // Forward event to storage
                select </span>{
                case d.outputEventCh &lt;- event:<span class="cov5" title="3"></span>
                default:<span class="cov1" title="1">
                        d.logger.Warnf("Dropped event %s due to full output channel", event.EventID)</span>
                }
        }
}

// Stop stops the detector
func (d *Detector) Stop() <span class="cov6" title="4">{
        d.wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package detect

import (
        "reflect"
        "sort"
        "strconv"
        "strings"
        "sync"

        "cerberus/core"
)

// RuleEngine evaluates rules against events
type RuleEngine struct {
        rules            []core.Rule
        correlationRules []core.CorrelationRule
        correlationState map[string][]*core.Event // ruleID -&gt; events in window
        stateMu          sync.RWMutex
        correlationTTL   int // seconds
}

// NewRuleEngine creates a new rule engine
func NewRuleEngine(rules []core.Rule, correlationRules []core.CorrelationRule, correlationTTL int) *RuleEngine <span class="cov10" title="29">{
        return &amp;RuleEngine{
                rules:            rules,
                correlationRules: correlationRules,
                correlationState: make(map[string][]*core.Event),
                correlationTTL:   correlationTTL,
        }
}</span>

// ResetCorrelationState clears the correlation state map
func (re *RuleEngine) ResetCorrelationState() <span class="cov1" title="1">{
        re.stateMu.Lock()
        defer re.stateMu.Unlock()
        re.correlationState = make(map[string][]*core.Event)
}</span>

// Evaluate evaluates all rules against an event and returns matching rules
func (re *RuleEngine) Evaluate(event *core.Event) []core.AlertableRule <span class="cov8" title="16">{
        var matches []core.AlertableRule
        for _, rule := range re.rules </span><span class="cov8" title="14">{
                if !rule.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="14">if re.evaluateRule(rule, event) </span><span class="cov7" title="12">{
                        matches = append(matches, rule)
                }</span>
        }
        <span class="cov8" title="16">return matches</span>
}

// EvaluateCorrelation evaluates correlation rules and returns matching ones
func (re *RuleEngine) EvaluateCorrelation(event *core.Event) []core.AlertableRule <span class="cov5" title="6">{
        var matches []core.AlertableRule
        for _, rule := range re.correlationRules </span><span class="cov4" title="4">{
                if re.evaluateCorrelationRule(rule, event) </span><span class="cov2" title="2">{
                        matches = append(matches, rule)
                }</span>
        }
        <span class="cov5" title="6">return matches</span>
}

// evaluateCorrelationRule checks if a correlation rule matches based on event sequence
func (re *RuleEngine) evaluateCorrelationRule(rule core.CorrelationRule, event *core.Event) bool <span class="cov7" title="10">{
        re.stateMu.Lock()
        defer re.stateMu.Unlock()

        // Add event to state in sorted order
        events := re.correlationState[rule.ID]
        // Find insertion point to maintain sorted order
        insertIndex := sort.Search(len(events), func(i int) bool </span><span class="cov5" title="5">{
                if events[i].Timestamp.Equal(event.Timestamp) </span><span class="cov5" title="5">{
                        return events[i].EventID &gt;= event.EventID
                }</span>
                <span class="cov0" title="0">return events[i].Timestamp.After(event.Timestamp)</span>
        })
        // Insert event at the correct position
        <span class="cov7" title="10">events = append(events[:insertIndex], append([]*core.Event{event}, events[insertIndex:]...)...)

        // Clean up expired events from the front before window filtering
        now := event.Timestamp
        for len(events) &gt; 0 &amp;&amp; now.Sub(events[0].Timestamp).Seconds() &gt; float64(re.correlationTTL) </span><span class="cov0" title="0">{
                events = events[1:]
        }</span>

        // Clean up old events outside the window
        <span class="cov7" title="10">windowStart := now.Add(-rule.Window)
        // Find the first event within the window
        startIndex := sort.Search(len(events), func(i int) bool </span><span class="cov8" title="15">{
                return events[i].Timestamp.After(windowStart) || events[i].Timestamp.Equal(windowStart)
        }</span>)
        <span class="cov7" title="10">validEvents := events[startIndex:]

        if len(validEvents) == 0 </span><span class="cov0" title="0">{
                delete(re.correlationState, rule.ID)
                return false
        }</span>
        <span class="cov7" title="10">re.correlationState[rule.ID] = validEvents

        // Check if sequence matches
        if len(validEvents) &lt; len(rule.Sequence) </span><span class="cov5" title="5">{
                return false
        }</span>

        // Check the last len(sequence) events match the sequence in order
        <span class="cov5" title="5">start := len(validEvents) - len(rule.Sequence)
        for i, eventType := range rule.Sequence </span><span class="cov7" title="10">{
                if validEvents[start+i].EventType != eventType </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Also evaluate conditions if any (on the last event or all?)
        // For simplicity, evaluate conditions on the triggering event
        <span class="cov4" title="4">if len(rule.Conditions) &gt; 0 </span><span class="cov1" title="1">{
                if !re.evaluateRule(core.Rule{Conditions: rule.Conditions}, event) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Clear state after successful match
        <span class="cov3" title="3">delete(re.correlationState, rule.ID)

        return true</span>
}

// evaluateRule checks if a rule matches the event
func (re *RuleEngine) evaluateRule(rule core.Rule, event *core.Event) bool <span class="cov8" title="18">{
        if len(rule.Conditions) == 0 </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="17">result := re.evaluateCondition(rule.Conditions[0], event)
        for i := 1; i &lt; len(rule.Conditions); i++ </span><span class="cov1" title="1">{
                cond := rule.Conditions[i]
                condResult := re.evaluateCondition(cond, event)
                if cond.Logic == "OR" </span><span class="cov0" title="0">{
                        result = result || condResult
                }</span> else<span class="cov1" title="1"> {
                        result = result &amp;&amp; condResult
                }</span>
        }
        <span class="cov8" title="17">return result</span>
}

// evaluateCondition evaluates a single condition against the event
func (re *RuleEngine) evaluateCondition(cond core.Condition, event *core.Event) bool <span class="cov9" title="20">{
        fieldValue := re.getFieldValue(cond.Field, event)
        if fieldValue == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="19">switch cond.Operator </span>{
        case "equals":<span class="cov7" title="11">
                return reflect.DeepEqual(fieldValue, cond.Value)</span>
        case "not_equals":<span class="cov2" title="2">
                return !reflect.DeepEqual(fieldValue, cond.Value)</span>
        case "contains":<span class="cov1" title="1">
                if str, ok := fieldValue.(string); ok </span><span class="cov1" title="1">{
                        if valStr, ok := cond.Value.(string); ok </span><span class="cov1" title="1">{
                                return strings.Contains(str, valStr)
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        case "starts_with":<span class="cov1" title="1">
                if str, ok := fieldValue.(string); ok </span><span class="cov1" title="1">{
                        if valStr, ok := cond.Value.(string); ok </span><span class="cov1" title="1">{
                                return strings.HasPrefix(str, valStr)
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        case "ends_with":<span class="cov1" title="1">
                if str, ok := fieldValue.(string); ok </span><span class="cov1" title="1">{
                        if valStr, ok := cond.Value.(string); ok </span><span class="cov1" title="1">{
                                return strings.HasSuffix(str, valStr)
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        case "regex":<span class="cov1" title="1">
                if str, ok := fieldValue.(string); ok </span><span class="cov1" title="1">{
                        if cond.Regex != nil </span><span class="cov1" title="1">{
                                return cond.Regex.MatchString(str)
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        case "greater_than":<span class="cov1" title="1">
                return compareNumbers(fieldValue, cond.Value, func(a, b float64) bool </span><span class="cov1" title="1">{ return a &gt; b }</span>)
        case "less_than":<span class="cov1" title="1">
                return compareNumbers(fieldValue, cond.Value, func(a, b float64) bool </span><span class="cov1" title="1">{ return a &lt; b }</span>)
        case "greater_than_or_equal":<span class="cov0" title="0">
                return compareNumbers(fieldValue, cond.Value, func(a, b float64) bool </span><span class="cov0" title="0">{ return a &gt;= b }</span>)
        case "less_than_or_equal":<span class="cov0" title="0">
                return compareNumbers(fieldValue, cond.Value, func(a, b float64) bool </span><span class="cov0" title="0">{ return a &lt;= b }</span>)
        }
        <span class="cov0" title="0">return false</span>
}

// compareNumbers compares two values as numbers
func compareNumbers(a, b interface{}, cmp func(float64, float64) bool) bool <span class="cov6" title="7">{
        var fa, fb float64
        var ok bool

        // Try to convert a to float64
        if fa, ok = a.(float64); !ok </span><span class="cov3" title="3">{
                if str, ok := a.(string); ok </span><span class="cov3" title="3">{
                        if parsed, err := strconv.ParseFloat(str, 64); err == nil </span><span class="cov1" title="1">{
                                fa = parsed
                        }</span> else<span class="cov2" title="2"> {
                                return false
                        }</span>
                } else<span class="cov0" title="0"> {
                        return false
                }</span>
        }

        // Try to convert b to float64
        <span class="cov5" title="5">if fb, ok = b.(float64); !ok </span><span class="cov1" title="1">{
                if str, ok := b.(string); ok </span><span class="cov1" title="1">{
                        if parsed, err := strconv.ParseFloat(str, 64); err == nil </span><span class="cov1" title="1">{
                                fb = parsed
                        }</span> else<span class="cov0" title="0"> {
                                return false
                        }</span>
                } else<span class="cov0" title="0"> {
                        return false
                }</span>
        }

        <span class="cov5" title="5">return cmp(fa, fb)</span>
}

// getFieldValue extracts field value from event using dot notation (e.g., "fields.key")
func (re *RuleEngine) getFieldValue(field string, event *core.Event) interface{} <span class="cov9" title="24">{
        parts := strings.Split(field, ".")

        // Start with top-level fields merged with event fields
        current := make(map[string]interface{})
        current["event_id"] = event.EventID
        current["timestamp"] = event.Timestamp
        current["source_format"] = event.SourceFormat
        current["source_ip"] = event.SourceIP
        current["event_type"] = event.EventType
        current["severity"] = event.Severity
        current["raw_data"] = event.RawData
        for k, v := range event.Fields </span><span class="cov7" title="10">{
                current[k] = v
        }</span>

        // Navigate through nested maps using dot notation
        <span class="cov9" title="24">for i, part := range parts </span><span class="cov9" title="25">{
                val := current[part]
                if i &lt; len(parts)-1 </span><span class="cov2" title="2">{
                        // For non-last parts, must be a map to navigate further
                        if m, ok := val.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                                current = m
                        }</span> else<span class="cov1" title="1"> {
                                return nil
                        }</span>
                } else<span class="cov9" title="23"> {
                        // For the last part, return whatever value it has
                        return val
                }</span>
        }
        <span class="cov0" title="0">return nil</span> // Should not reach here
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package detect

import (
        "context"
        "fmt"
        "time"

        "cerberus/core"
        "cerberus/storage"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.uber.org/zap"
)

// EventReplay handles event replay functionality
type EventReplay struct {
        eventStorage *storage.EventStorage
        ruleEngine   *RuleEngine
        alertCh      chan&lt;- *core.Alert
        logger       *zap.SugaredLogger
}

// NewEventReplay creates a new event replay handler
func NewEventReplay(eventStorage *storage.EventStorage, ruleEngine *RuleEngine, alertCh chan&lt;- *core.Alert, logger *zap.SugaredLogger) *EventReplay <span class="cov8" title="1">{
        return &amp;EventReplay{
                eventStorage: eventStorage,
                ruleEngine:   ruleEngine,
                alertCh:      alertCh,
                logger:       logger,
        }
}</span>

// ReplayEvents replays events from a time range
func (er *EventReplay) ReplayEvents(startTime, endTime time.Time) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Query events in the time range
        filter := bson.M{
                "timestamp": bson.M{
                        "$gte": startTime,
                        "$lte": endTime,
                },
        }

        opts := options.Find().SetSort(bson.M{"timestamp": 1})
        cursor, err := er.eventStorage.EventsColl.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to query events for replay: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var events []*core.Event
        if err = cursor.All(ctx, &amp;events); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode events for replay: %w", err)
        }</span>

        <span class="cov0" title="0">er.logger.Infof("Replaying %d events from %s to %s", len(events), startTime, endTime)

        // Reset correlation state to prevent interference from previous runs
        er.ruleEngine.ResetCorrelationState()

        // Process events through the rule engine
        for _, event := range events </span><span class="cov0" title="0">{
                matchingRules := er.ruleEngine.Evaluate(event)
                matchingCorrelationRules := er.ruleEngine.EvaluateCorrelation(event)

                for _, rule := range matchingRules </span><span class="cov0" title="0">{
                        alert := core.NewAlert(rule.GetID(), event.EventID, rule.GetSeverity(), event)
                        select </span>{
                        case er.alertCh &lt;- alert:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                er.logger.Warnf("Alert channel full during replay")</span>
                        }
                }

                <span class="cov0" title="0">for _, rule := range matchingCorrelationRules </span><span class="cov0" title="0">{
                        alert := core.NewAlert(rule.GetID(), event.EventID, rule.GetSeverity(), event)
                        select </span>{
                        case er.alertCh &lt;- alert:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                er.logger.Warnf("Alert channel full during replay")</span>
                        }
                }
        }

        <span class="cov0" title="0">er.logger.Infof("Event replay completed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package detect

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "cerberus/core"
        "cerberus/storage"
        "github.com/xeipuuv/gojsonschema"
        "go.uber.org/zap"
        "gopkg.in/yaml.v3"
)

// compileRegexInRules compiles regex patterns in rules
func compileRegexInRules(rules []core.Rule, ruleType string, logger *zap.SugaredLogger) error <span class="cov1" title="1">{
        for i := range rules </span><span class="cov6" title="2">{
                for j := range rules[i].Conditions </span><span class="cov10" title="3">{
                        cond := &amp;rules[i].Conditions[j]
                        if cond.Operator == "regex" </span><span class="cov0" title="0">{
                                if valStr, ok := cond.Value.(string); ok </span><span class="cov0" title="0">{
                                        regex, err := regexp.Compile(valStr)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("invalid regex pattern in %s %s condition %d", ruleType, rules[i].ID, j)
                                        }</span>
                                        <span class="cov0" title="0">cond.Regex = regex</span>
                                }
                        }
                }
        }
        <span class="cov1" title="1">return nil</span>
}

// compileRegexInCorrelationRules compiles regex patterns in correlation rules
func compileRegexInCorrelationRules(rules []core.CorrelationRule, ruleType string, logger *zap.SugaredLogger) error <span class="cov0" title="0">{
        for i := range rules </span><span class="cov0" title="0">{
                for j := range rules[i].Conditions </span><span class="cov0" title="0">{
                        cond := &amp;rules[i].Conditions[j]
                        if cond.Operator == "regex" </span><span class="cov0" title="0">{
                                if valStr, ok := cond.Value.(string); ok </span><span class="cov0" title="0">{
                                        regex, err := regexp.Compile(valStr)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("invalid regex pattern in %s %s condition %d", ruleType, rules[i].ID, j)
                                        }</span>
                                        <span class="cov0" title="0">cond.Regex = regex</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// LoadRules loads rules from a JSON file
func LoadRules(filename string, logger *zap.SugaredLogger) ([]core.Rule, error) <span class="cov1" title="1">{
        return loadRulesFromFile(filename, logger)
}</span>

// LoadCorrelationRules loads correlation rules from a JSON file
func LoadCorrelationRules(filename string, logger *zap.SugaredLogger) ([]core.CorrelationRule, error) <span class="cov0" title="0">{
        return loadCorrelationRulesFromFile(filename, logger)
}</span>

// LoadRulesFromDB loads rules from MongoDB
func LoadRulesFromDB(ruleStorage *storage.RuleStorage) ([]core.Rule, error) <span class="cov0" title="0">{
        return ruleStorage.GetRules()
}</span>

// loadRulesFromFile loads rules from a JSON file (internal)
func loadRulesFromFile(filename string, logger *zap.SugaredLogger) ([]core.Rule, error) <span class="cov1" title="1">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read rules file: %w", err)
        }</span>

        // Validate against JSON schema (optional)
        // Assume schema is in the same directory as the rules file
        <span class="cov1" title="1">schemaFilename := filepath.Join(filepath.Dir(filename), "rules_schema.json")
        schemaData, err := os.ReadFile(schemaFilename)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("Schema file not found, skipping validation: %v", err)
        }</span> else<span class="cov1" title="1"> {
                schemaLoader := gojsonschema.NewBytesLoader(schemaData)
                documentLoader := gojsonschema.NewBytesLoader(data)

                result, err := gojsonschema.Validate(schemaLoader, documentLoader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to validate rules against schema: %w", err)
                }</span>
                <span class="cov1" title="1">if !result.Valid() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("rules validation failed: %v", result.Errors())
                }</span>
        }

        <span class="cov1" title="1">var rules core.Rules
        if strings.HasSuffix(filename, ".yaml") || strings.HasSuffix(filename, ".yml") </span><span class="cov0" title="0">{
                err = yaml.Unmarshal(data, &amp;rules)
        }</span> else<span class="cov1" title="1"> {
                err = json.Unmarshal(data, &amp;rules)
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal rules: %w", err)
        }</span>

        // Compile regex patterns
        <span class="cov1" title="1">if err := compileRegexInRules(rules.Rules, "rule", logger); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate rules
        <span class="cov1" title="1">for _, rule := range rules.Rules </span><span class="cov6" title="2">{
                if rule.ID == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("rule missing ID")
                }</span>
                <span class="cov6" title="2">if len(rule.Conditions) == 0 </span><span class="cov0" title="0">{
                        logger.Warnf("Warning: rule %s has no conditions", rule.ID)
                }</span>
        }

        <span class="cov1" title="1">logger.Infof("Loaded %d rules from %s", len(rules.Rules), filename)
        return rules.Rules, nil</span>
}

// loadCorrelationRulesFromFile loads correlation rules from a JSON file (internal)
func loadCorrelationRulesFromFile(filename string, logger *zap.SugaredLogger) ([]core.CorrelationRule, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read correlation rules file: %w", err)
        }</span>

        // Validate against JSON schema (optional)
        <span class="cov0" title="0">if !strings.HasSuffix(filename, ".yaml") &amp;&amp; !strings.HasSuffix(filename, ".yml") </span><span class="cov0" title="0">{
                schemaFilename := filepath.Join(filepath.Dir(filename), "correlation_rules_schema.json")
                schemaData, err := os.ReadFile(schemaFilename)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Schema file not found, skipping validation: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        schemaLoader := gojsonschema.NewBytesLoader(schemaData)
                        documentLoader := gojsonschema.NewBytesLoader(data)

                        result, err := gojsonschema.Validate(schemaLoader, documentLoader)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to validate correlation rules against schema: %w", err)
                        }</span>
                        <span class="cov0" title="0">if !result.Valid() </span><span class="cov0" title="0">{
                                var errors []string
                                for _, desc := range result.Errors() </span><span class="cov0" title="0">{
                                        errors = append(errors, desc.String())
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("correlation rules validation failed: %s", strings.Join(errors, "; "))</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                logger.Warnf("Schema validation skipped for YAML file: %s", filename)
        }</span>

        <span class="cov0" title="0">var rules core.CorrelationRules
        if strings.HasSuffix(filename, ".yaml") || strings.HasSuffix(filename, ".yml") </span><span class="cov0" title="0">{
                err = yaml.Unmarshal(data, &amp;rules)
        }</span> else<span class="cov0" title="0"> {
                err = json.Unmarshal(data, &amp;rules)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal correlation rules: %w", err)
        }</span>

        // Compile regex patterns
        <span class="cov0" title="0">if err := compileRegexInCorrelationRules(rules.Rules, "correlation rule", logger); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate rules
        <span class="cov0" title="0">for _, rule := range rules.Rules </span><span class="cov0" title="0">{
                if rule.ID == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("correlation rule missing ID")
                }</span>
                <span class="cov0" title="0">if len(rule.Sequence) == 0 </span><span class="cov0" title="0">{
                        logger.Warnf("Warning: correlation rule %s has no sequence", rule.ID)
                }</span>
        }

        <span class="cov0" title="0">logger.Infof("Loaded %d correlation rules from %s", len(rules.Rules), filename)
        return rules.Rules, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ingest

import (
        "bufio"
        "fmt"
        "net"
        "strings"
        "sync"
        "time"

        "cerberus/core"
        "go.uber.org/zap"
        "golang.org/x/time/rate"
)

// BaseListener provides common functionality for listeners
type BaseListener struct {
        host        string
        port        int
        limiter     *rate.Limiter
        eventCh     chan&lt;- *core.Event
        stopCh      chan struct{}
        wg          sync.WaitGroup
        logger      *zap.SugaredLogger
        udpConn     net.PacketConn
        tcpListener net.Listener
}

// NewBaseListener creates a new base listener
func NewBaseListener(host string, port int, rateLimit int, eventCh chan&lt;- *core.Event, logger *zap.SugaredLogger) *BaseListener <span class="cov9" title="14">{
        return &amp;BaseListener{
                host:    host,
                port:    port,
                limiter: rate.NewLimiter(rate.Limit(rateLimit), rateLimit),
                eventCh: eventCh,
                stopCh:  make(chan struct{}),
                logger:  logger,
        }
}</span>

// processEvent processes a raw event string, parses it, and sends it to the event channel
func (b *BaseListener) processEvent(raw string, sourceIP string, parseFunc func(string) (*core.Event, error), name string) <span class="cov5" title="5">{
        if !b.limiter.Allow() </span><span class="cov1" title="1">{
                b.logger.Warnf("Rate limit exceeded for %s", name)
                return
        }</span>
        <span class="cov5" title="4">event, err := parseFunc(raw)
        if err != nil </span><span class="cov0" title="0">{
                b.logger.Errorf("Failed to parse %s: %v", name, err)
                return
        }</span>
        <span class="cov5" title="4">event.SourceIP = sourceIP
        select </span>{
        case b.eventCh &lt;- event:<span class="cov5" title="4"></span>
        default:<span class="cov0" title="0">
                b.logger.Warnf("Event channel full, dropping %s event", name)</span>
        }
}

// StartUDP starts a UDP listener with the given parse function
func (b *BaseListener) StartUDP(parseFunc func(string) (*core.Event, error), name string) <span class="cov7" title="8">{
        addr := fmt.Sprintf("%s:%d", b.host, b.port)
        conn, err := net.ListenPacket("udp", addr)
        if err != nil </span><span class="cov0" title="0">{
                b.logger.Errorf("Failed to start %s UDP listener: %v", name, err)
                return
        }</span>
        <span class="cov7" title="8">b.udpConn = conn
        b.logger.Infof("%s UDP listener started on %s", name, addr)
        b.wg.Add(1)
        defer b.wg.Done()

        buffer := make([]byte, 65536)
        for </span><span class="cov10" title="19">{
                select </span>{
                case &lt;-b.stopCh:<span class="cov7" title="8">
                        return</span>
                default:<span class="cov8" title="11"></span>
                }
                <span class="cov8" title="11">conn.SetReadDeadline(time.Now().Add(time.Second))
                n, addr, err := conn.ReadFrom(buffer)
                if err != nil </span><span class="cov7" title="8">{
                        if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() </span><span class="cov5" title="5">{
                                continue</span>
                        }
                        <span class="cov4" title="3">b.logger.Errorf("%s UDP read error: %v", name, err)
                        continue</span>
                }
                <span class="cov4" title="3">raw := strings.TrimSpace(string(buffer[:n]))
                if raw == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="3">b.processEvent(raw, addr.String(), parseFunc, name+" UDP")</span>
        }
}

// StartTCP starts a TCP listener with the given parse function
func (b *BaseListener) StartTCP(parseFunc func(string) (*core.Event, error), name string) <span class="cov3" title="2">{
        addr := fmt.Sprintf("%s:%d", b.host, b.port)
        listener, err := net.Listen("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                b.logger.Errorf("Failed to start %s TCP listener: %v", name, err)
                return
        }</span>
        <span class="cov3" title="2">b.tcpListener = listener
        b.logger.Infof("%s TCP listener started on %s", name, addr)
        b.wg.Add(1)
        defer b.wg.Done()

        for </span><span class="cov5" title="4">{
                select </span>{
                case &lt;-b.stopCh:<span class="cov3" title="2">
                        return</span>
                default:<span class="cov3" title="2"></span>
                }
                <span class="cov3" title="2">conn, err := listener.Accept()
                if err != nil </span><span class="cov3" title="2">{
                        b.logger.Errorf("%s TCP accept error: %v", name, err)
                        continue</span>
                }
                <span class="cov0" title="0">b.wg.Add(1)
                go b.handleTCPConnection(conn, parseFunc, name)</span>
        }
}

func (b *BaseListener) handleTCPConnection(conn net.Conn, parseFunc func(string) (*core.Event, error), name string) <span class="cov0" title="0">{
        defer conn.Close()
        defer b.wg.Done()

        scanner := bufio.NewScanner(conn)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">b.processEvent(line, conn.RemoteAddr().String(), parseFunc, name+" TCP")</span>
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                b.logger.Errorf("%s scanner error: %v", name, err)
        }</span>
}

// Stop stops the listener
func (b *BaseListener) Stop() <span class="cov4" title="3">{
        close(b.stopCh)
        if b.udpConn != nil </span><span class="cov4" title="3">{
                b.udpConn.Close()
        }</span>
        <span class="cov4" title="3">if b.tcpListener != nil </span><span class="cov3" title="2">{
                b.tcpListener.Close()
        }</span>
        <span class="cov4" title="3">b.wg.Wait()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package ingest

import (
        "cerberus/core"
        "go.uber.org/zap"
)

// CEFListener listens for CEF messages over TCP and UDP
type CEFListener struct {
        *BaseListener
}

// NewCEFListener creates a new CEF listener
func NewCEFListener(host string, port int, rateLimit int, eventCh chan&lt;- *core.Event, logger *zap.SugaredLogger) *CEFListener <span class="cov10" title="2">{
        return &amp;CEFListener{
                BaseListener: NewBaseListener(host, port, rateLimit, eventCh, logger),
        }
}</span>

// Start starts the CEF listener on TCP and UDP
func (c *CEFListener) Start() error <span class="cov1" title="1">{
        // Start TCP listener
        go c.BaseListener.StartTCP(ParseCEF, "CEF")
        // Start UDP listener
        go c.BaseListener.StartUDP(ParseCEF, "CEF")
        return nil
}</span>

// Stop stops the listener
func (c *CEFListener) Stop() <span class="cov1" title="1">{
        c.BaseListener.Stop()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package ingest

import (
        "context"
        "fmt"
        "io"
        "net/http"

        "cerberus/core"
        "github.com/gorilla/mux"
        "go.uber.org/zap"
)

const maxBodySize = 1024 * 1024 // 1MB limit for JSON requests

// JSONListener listens for JSON events over HTTP POST and UDP
type JSONListener struct {
        *BaseListener
        tls      bool
        certFile string
        keyFile  string
        server   *http.Server
}

// NewJSONListener creates a new JSON listener
func NewJSONListener(host string, port int, tls bool, certFile, keyFile string, rateLimit int, eventCh chan&lt;- *core.Event, logger *zap.SugaredLogger) *JSONListener <span class="cov10" title="6">{
        return &amp;JSONListener{
                BaseListener: NewBaseListener(host, port, rateLimit, eventCh, logger),
                tls:          tls,
                certFile:     certFile,
                keyFile:      keyFile,
        }
}</span>

// Start starts the HTTP server and UDP listener
func (j *JSONListener) Start() error <span class="cov9" title="5">{
        // Start HTTP server
        go func() </span><span class="cov9" title="5">{
                r := mux.NewRouter()
                r.HandleFunc("/api/v1/ingest/json", j.handlePost).Methods("POST")

                addr := fmt.Sprintf("%s:%d", j.host, j.port)
                j.server = &amp;http.Server{
                        Addr:    addr,
                        Handler: r,
                }

                j.logger.Infof("JSON HTTP listener started on %s", addr)

                j.wg.Add(1)
                go func() </span><span class="cov9" title="5">{
                        defer j.wg.Done()
                        var err error
                        if j.tls </span><span class="cov0" title="0">{
                                err = j.server.ListenAndServeTLS(j.certFile, j.keyFile)
                        }</span> else<span class="cov9" title="5"> {
                                err = j.server.ListenAndServe()
                        }</span>
                        <span class="cov9" title="5">if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                j.logger.Errorf("JSON server error: %v", err)
                        }</span>
                }()
        }()

        // Start UDP listener
        <span class="cov9" title="5">go j.BaseListener.StartUDP(ParseJSON, "JSON")
        return nil</span>
}

func (j *JSONListener) handlePost(w http.ResponseWriter, r *http.Request) <span class="cov9" title="5">{
        if !j.limiter.Allow() </span><span class="cov1" title="1">{
                http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
                return
        }</span>

        <span class="cov7" title="4">body, err := io.ReadAll(io.LimitReader(r.Body, maxBodySize))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Bad request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov7" title="4">if len(body) &gt;= maxBodySize </span><span class="cov1" title="1">{
                http.Error(w, "Request body too large", http.StatusRequestEntityTooLarge)
                return
        }</span>

        <span class="cov6" title="3">raw := string(body)
        event, err := ParseJSON(raw)
        if err != nil </span><span class="cov1" title="1">{
                j.logger.Errorf("Failed to parse JSON: %v", err)
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>
        <span class="cov4" title="2">event.SourceIP = r.RemoteAddr

        select </span>{
        case j.eventCh &lt;- event:<span class="cov1" title="1">
                w.WriteHeader(http.StatusAccepted)</span>
        default:<span class="cov1" title="1">
                j.logger.Warn("Event channel full, dropping JSON event")
                http.Error(w, "Service unavailable", http.StatusServiceUnavailable)</span>
        }
}

// Stop stops the server and listeners
func (j *JSONListener) Stop() <span class="cov9" title="5">{
        close(j.stopCh)
        if j.server != nil </span><span class="cov9" title="5">{
                j.server.Shutdown(context.Background())
        }</span>
        <span class="cov9" title="5">j.wg.Wait()</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package ingest

import (
        "encoding/json"
        "fmt"
        "html"
        "regexp"
        "strconv"
        "strings"

        "cerberus/core"
)

const maxFieldLength = 50000
const maxSanitizeDepth = 20

// sanitizeFields sanitizes event fields for security
func sanitizeFields(fields map[string]interface{}, depth int) error <span class="cov8" title="42">{
        if depth &gt; maxSanitizeDepth </span><span class="cov1" title="1">{
                return fmt.Errorf("maximum sanitization depth exceeded")
        }</span>
        <span class="cov8" title="41">for k, v := range fields </span><span class="cov10" title="79">{
                switch val := v.(type) </span>{
                case string:<span class="cov8" title="47">
                        // Escape HTML to prevent XSS
                        sanitized := html.EscapeString(val)
                        // Limit length to prevent DoS
                        if len(sanitized) &gt; maxFieldLength </span><span class="cov1" title="1">{
                                sanitized = sanitized[:maxFieldLength] + "..."
                        }</span>
                        <span class="cov8" title="47">fields[k] = sanitized</span>
                case map[string]interface{}:<span class="cov7" title="22">
                        // Recursively sanitize nested maps
                        if err := sanitizeFields(val, depth+1); err != nil </span><span class="cov7" title="21">{
                                return err
                        }</span>
                case []interface{}:<span class="cov1" title="1">
                        // Recursively sanitize array elements
                        for i, elem := range val </span><span class="cov2" title="2">{
                                if elemMap, ok := elem.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                                        if err := sanitizeFields(elemMap, depth+1); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                } else<span class="cov1" title="1"> if elemStr, ok := elem.(string); ok </span><span class="cov1" title="1">{
                                        sanitized := html.EscapeString(elemStr)
                                        if len(sanitized) &gt; maxFieldLength </span><span class="cov0" title="0">{
                                                sanitized = sanitized[:maxFieldLength] + "..."
                                        }</span>
                                        <span class="cov1" title="1">val[i] = sanitized</span>
                                }
                        }
                }
        }
        <span class="cov7" title="20">return nil</span>
}

// ParseSyslog parses a raw Syslog string into an Event
func ParseSyslog(raw string) (*core.Event, error) <span class="cov3" title="4">{
        event := core.NewEvent()
        event.SourceFormat = "syslog"
        event.RawData = raw

        event.Fields = map[string]interface{}{
                "raw": raw,
        }

        // RFC3164 syslog regex: &lt;pri&gt;timestamp hostname message
        // pri: &lt;number&gt;, timestamp: MMM dd hh:mm:ss, hostname: string, message: rest
        re := regexp.MustCompile(`^&lt;(\d+)&gt;(\w{3}\s+\d+\s+\d+:\d+:\d+)\s+(\S+)\s+(.+)$`)
        matches := re.FindStringSubmatch(raw)
        if len(matches) == 5 </span><span class="cov2" title="2">{
                pri, err := strconv.Atoi(matches[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid priority in syslog message: %w", err)
                }</span>
                <span class="cov2" title="2">facility := pri / 8
                severity := pri % 8
                event.Fields["priority"] = pri
                event.Fields["facility"] = facility
                event.Fields["severity_code"] = severity
                event.Fields["timestamp"] = matches[2]
                event.Fields["hostname"] = matches[3]
                event.Fields["message"] = matches[4]
                event.Severity = getSeverityFromCode(severity)</span>
        } else<span class="cov2" title="2"> {
                // Fallback to simple parsing if regex fails
                parts := strings.Fields(raw)
                if len(parts) &gt;= 4 &amp;&amp; strings.HasPrefix(parts[0], "&lt;") &amp;&amp; strings.HasSuffix(parts[0], "&gt;") </span><span class="cov1" title="1">{
                        event.Fields["timestamp"] = parts[1] + " " + parts[2]
                        event.Fields["hostname"] = parts[3]
                        event.Fields["message"] = strings.Join(parts[4:], " ")
                }</span>
                <span class="cov2" title="2">event.Severity = "info"</span>
        }

        <span class="cov3" title="4">if err := sanitizeFields(event.Fields, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="4">event.EventType = "syslog"
        return event, nil</span>
}

// getSeverityFromCode converts syslog severity code to string
func getSeverityFromCode(code int) string <span class="cov6" title="12">{
        severities := []string{"emerg", "alert", "crit", "err", "warning", "notice", "info", "debug"}
        if code &gt;= 0 &amp;&amp; code &lt; len(severities) </span><span class="cov5" title="10">{
                return severities[code]
        }</span>
        <span class="cov2" title="2">return "info"</span>
}

// getSeverityFromCEFCode converts CEF severity code (0-10) to string
func getSeverityFromCEFCode(code int) string <span class="cov2" title="2">{
        cefSeverities := []string{"unknown", "low", "warning", "average", "high", "very-high", "critical", "error", "warning", "notice", "info"}
        if code &gt;= 0 &amp;&amp; code &lt; len(cefSeverities) </span><span class="cov2" title="2">{
                return cefSeverities[code]
        }</span>
        <span class="cov0" title="0">return "info"</span>
}

// ParseCEF parses a raw CEF string into an Event
func ParseCEF(raw string) (*core.Event, error) <span class="cov3" title="3">{
        event := core.NewEvent()
        event.SourceFormat = "cef"
        event.RawData = raw

        // CEF format: CEF:Version|Device Vendor|Device Product|Device Version|Device Event Class ID|Name|Severity|Extension
        parts := strings.SplitN(raw, "|", 8)
        if len(parts) &lt; 8 || !strings.HasPrefix(parts[0], "CEF:") </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid CEF format")
        }</span>

        <span class="cov2" title="2">severityCode, err := strconv.Atoi(parts[6])
        if err != nil </span><span class="cov0" title="0">{
                severityCode = 6 // default to info
        }</span>
        <span class="cov2" title="2">event.Fields = map[string]interface{}{
                "cef_version":    strings.TrimPrefix(parts[0], "CEF:"),
                "device_vendor":  parts[1],
                "device_product": parts[2],
                "device_version": parts[3],
                "event_class_id": parts[4],
                "name":           parts[5],
                "severity":       parts[6],
                "severity_code":  severityCode,
        }

        // Parse extension field: key=value pairs separated by spaces
        extensionParts := strings.Fields(parts[7])
        for _, part := range extensionParts </span><span class="cov4" title="6">{
                if kv := strings.SplitN(part, "=", 2); len(kv) == 2 </span><span class="cov4" title="6">{
                        event.Fields[kv[0]] = kv[1]
                }</span>
        }
        <span class="cov2" title="2">if err := sanitizeFields(event.Fields, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">event.EventType = "cef"
        event.Severity = getSeverityFromCEFCode(severityCode)
        return event, nil</span>
}

// ParseJSON parses a raw JSON string into an Event
func ParseJSON(raw string) (*core.Event, error) <span class="cov5" title="10">{
        event := core.NewEvent()
        event.SourceFormat = "json"
        event.RawData = raw

        var data map[string]interface{}
        if err := json.Unmarshal([]byte(raw), &amp;data); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>

        <span class="cov5" title="8">event.Fields = data
        if err := sanitizeFields(event.Fields, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="8">if et, ok := data["event_type"].(string); ok </span><span class="cov1" title="1">{
                event.EventType = et
        }</span>
        <span class="cov5" title="8">if sev, ok := data["severity"].(string); ok </span><span class="cov2" title="2">{
                event.Severity = sev
        }</span>
        <span class="cov5" title="8">return event, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package ingest

import (
        "cerberus/core"
        "go.uber.org/zap"
)

const (
        udpBufferSize = 65536
)

// SyslogListener listens for Syslog messages over TCP/UDP
type SyslogListener struct {
        *BaseListener
}

// NewSyslogListener creates a new Syslog listener
func NewSyslogListener(host string, port int, rateLimit int, eventCh chan&lt;- *core.Event, logger *zap.SugaredLogger) *SyslogListener <span class="cov10" title="2">{
        return &amp;SyslogListener{
                BaseListener: NewBaseListener(host, port, rateLimit, eventCh, logger),
        }
}</span>

// Start starts the Syslog listener on TCP and UDP
func (s *SyslogListener) Start() error <span class="cov1" title="1">{
        // Start TCP listener
        go s.BaseListener.StartTCP(ParseSyslog, "Syslog")
        // Start UDP listener
        go s.BaseListener.StartUDP(ParseSyslog, "Syslog")
        return nil
}</span>

// Stop stops the listener
func (s *SyslogListener) Stop() <span class="cov1" title="1">{
        s.BaseListener.Stop()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "cerberus/api"
        "cerberus/config"
        "cerberus/core"
        "cerberus/detect"
        "cerberus/ingest"
        "cerberus/storage"

        "github.com/spf13/viper"
        "go.uber.org/zap"
)

// initLogger initializes the logger
func initLogger() (*zap.Logger, *zap.SugaredLogger, error) <span class="cov10" title="2">{
        logger, err := zap.NewProduction()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create logger: %w", err)
        }</span>
        <span class="cov10" title="2">sugar := logger.Sugar()
        return logger, sugar, nil</span>
}

// initConfig loads the configuration
func initConfig(sugar *zap.SugaredLogger) *config.Config <span class="cov1" title="1">{
        cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                sugar.Fatalf("Failed to load config: %v", err)
        }</span>
        <span class="cov1" title="1">if viper.ConfigFileUsed() == "" </span><span class="cov0" title="0">{
                sugar.Info("No config file found, using defaults and env vars")
        }</span>
        <span class="cov1" title="1">sugar.Infow("Config loaded",
                "mongodb_enabled", cfg.MongoDB.Enabled,
                "syslog_port", cfg.Listeners.Syslog.Port)
        return cfg</span>
}

// initMongoDB initializes MongoDB connection
func initMongoDB(cfg *config.Config, sugar *zap.SugaredLogger) *storage.MongoDB <span class="cov0" title="0">{
        var mongoDB *storage.MongoDB
        if cfg.MongoDB.Enabled </span><span class="cov0" title="0">{
                var err error
                mongoDB, err = storage.NewMongoDB(cfg.MongoDB.URI, cfg.MongoDB.Database, cfg.MongoDB.MaxPoolSize, sugar)
                if err != nil </span><span class="cov0" title="0">{
                        sugar.Fatalf("Failed to connect to MongoDB: %v", err)
                }</span>
                <span class="cov0" title="0">sugar.Info("Connected to MongoDB successfully")</span>
        } else<span class="cov0" title="0"> {
                sugar.Warn("MongoDB is disabled, running without persistent storage")
        }</span>
        <span class="cov0" title="0">return mongoDB</span>
}

// startStorageWorkers starts storage workers and retention manager
func startStorageWorkers(mongoDB *storage.MongoDB, cfg *config.Config, processedEventCh chan *core.Event, alertCh chan *core.Alert, sugar *zap.SugaredLogger) (*storage.EventStorage, *storage.AlertStorage, *storage.RuleStorage, *storage.ActionStorage, *storage.CorrelationRuleStorage, *storage.RetentionManager) <span class="cov0" title="0">{
        var eventStorage *storage.EventStorage
        var alertStorage *storage.AlertStorage
        var ruleStorage *storage.RuleStorage
        var actionStorage *storage.ActionStorage
        var correlationRuleStorage *storage.CorrelationRuleStorage
        var retentionManager *storage.RetentionManager

        if mongoDB != nil </span><span class="cov0" title="0">{
                eventStorage = storage.NewEventStorage(mongoDB, cfg, processedEventCh, sugar)
                eventStorage.Start(cfg.Engine.WorkerCount)

                alertStorage = storage.NewAlertStorage(mongoDB, cfg, alertCh, sugar)
                alertStorage.Start(cfg.Engine.WorkerCount)

                ruleStorage = storage.NewRuleStorage(mongoDB)
                if err := ruleStorage.EnsureIndexes(); err != nil </span><span class="cov0" title="0">{
                        sugar.Fatalf("Failed to ensure rule indexes: %v", err)
                }</span>

                <span class="cov0" title="0">actionStorage = storage.NewActionStorage(mongoDB)
                if err := actionStorage.EnsureIndexes(); err != nil </span><span class="cov0" title="0">{
                        sugar.Fatalf("Failed to ensure action indexes: %v", err)
                }</span>

                <span class="cov0" title="0">correlationRuleStorage = storage.NewCorrelationRuleStorage(mongoDB)
                if err := correlationRuleStorage.EnsureIndexes(); err != nil </span><span class="cov0" title="0">{
                        sugar.Fatalf("Failed to ensure correlation rule indexes: %v", err)
                }</span>

                // Start retention manager for data cleanup
                <span class="cov0" title="0">retentionManager = storage.NewRetentionManager(eventStorage, alertStorage, cfg.Retention.Events, cfg.Retention.Alerts, sugar)
                retentionManager.Start()</span>
        } else<span class="cov0" title="0"> {
                // Drain channels to prevent blocking when no storage
                go func() </span><span class="cov0" title="0">{
                        for range processedEventCh </span>{<span class="cov0" title="0">
                                // Drop events
                        }</span>
                }()
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        for range alertCh </span>{<span class="cov0" title="0">
                                // Drop alerts
                        }</span>
                }()
        }

        <span class="cov0" title="0">return eventStorage, alertStorage, ruleStorage, actionStorage, correlationRuleStorage, retentionManager</span>
}

// initSystem initializes the system components
func initSystem(sugar *zap.SugaredLogger) (*config.Config, *storage.MongoDB, chan *core.Event, chan *core.Event, chan *core.Alert, *storage.EventStorage, *storage.AlertStorage, *storage.RuleStorage, *storage.ActionStorage, *storage.CorrelationRuleStorage, *storage.RetentionManager, []core.Rule, []core.CorrelationRule, error) <span class="cov0" title="0">{
        cfg := initConfig(sugar)

        mongoDB := initMongoDB(cfg, sugar)

        // Initialize communication channels
        rawEventCh := make(chan *core.Event, cfg.Engine.ChannelBufferSize)       // From listeners
        processedEventCh := make(chan *core.Event, cfg.Engine.ChannelBufferSize) // To storage
        alertCh := make(chan *core.Alert, cfg.Engine.ChannelBufferSize)

        eventStorage, alertStorage, ruleStorage, actionStorage, correlationRuleStorage, retentionManager := startStorageWorkers(mongoDB, cfg, processedEventCh, alertCh, sugar)

        // Load detection rules
        var rules []core.Rule
        var correlationRules []core.CorrelationRule
        var err error
        if cfg.MongoDB.Enabled </span><span class="cov0" title="0">{
                rules, err = detect.LoadRulesFromDB(ruleStorage)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, fmt.Errorf("failed to load rules from DB: %w", err)
                }</span>
                <span class="cov0" title="0">correlationRules, err = correlationRuleStorage.GetCorrelationRules()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, fmt.Errorf("failed to load correlation rules from DB: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                rules, err = detect.LoadRules(cfg.Rules.File, sugar)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, fmt.Errorf("failed to load rules from file: %w", err)
                }</span>
                <span class="cov0" title="0">sugar.Infof("Loaded %d rules from %s", len(rules), cfg.Rules.File)

                if cfg.CorrelationRules.File != "" </span><span class="cov0" title="0">{
                        correlationRules, err = detect.LoadCorrelationRules(cfg.CorrelationRules.File, sugar)
                        if err != nil </span><span class="cov0" title="0">{
                                sugar.Errorf("Failed to load correlation rules from file: %v", err)
                                correlationRules = []core.CorrelationRule{}
                        }</span>
                } else<span class="cov0" title="0"> {
                        correlationRules = []core.CorrelationRule{}
                }</span>
        }

        <span class="cov0" title="0">return cfg, mongoDB, rawEventCh, processedEventCh, alertCh, eventStorage, alertStorage, ruleStorage, actionStorage, correlationRuleStorage, retentionManager, rules, correlationRules, nil</span>
}

// startServices starts the detector, listeners, and API
func startServices(cfg *config.Config, mongoDB *storage.MongoDB, rawEventCh chan *core.Event, processedEventCh chan *core.Event, alertCh chan *core.Alert, eventStorage *storage.EventStorage, alertStorage *storage.AlertStorage, ruleStorage *storage.RuleStorage, actionStorage *storage.ActionStorage, correlationRuleStorage *storage.CorrelationRuleStorage, rules []core.Rule, correlationRules []core.CorrelationRule, sugar *zap.SugaredLogger) (*detect.Detector, *ingest.SyslogListener, *ingest.CEFListener, *ingest.JSONListener, *api.API) <span class="cov0" title="0">{
        // Initialize rule engine for event processing
        ruleEngine := detect.NewRuleEngine(rules, correlationRules, cfg.Engine.CorrelationStateTTL)

        // Start event detection engine
        detector := detect.NewDetector(ruleEngine, rawEventCh, processedEventCh, alertCh, cfg, sugar)
        detector.Start()

        // Create event listeners
        syslogListener := ingest.NewSyslogListener(cfg.Listeners.Syslog.Host, cfg.Listeners.Syslog.Port, cfg.Engine.RateLimit, rawEventCh, sugar)
        cefListener := ingest.NewCEFListener(cfg.Listeners.CEF.Host, cfg.Listeners.CEF.Port, cfg.Engine.RateLimit, rawEventCh, sugar)
        jsonListener := ingest.NewJSONListener(cfg.Listeners.JSON.Host, cfg.Listeners.JSON.Port, cfg.Listeners.JSON.TLS, cfg.Listeners.JSON.CertFile, cfg.Listeners.JSON.KeyFile, cfg.Engine.RateLimit, rawEventCh, sugar)

        // Start listeners concurrently
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                sugar.Errorw("Syslog listener panicked", "panic", r)
                        }</span>
                }()
                <span class="cov0" title="0">if err := syslogListener.Start(); err != nil </span><span class="cov0" title="0">{
                        sugar.Errorw("Failed to start syslog listener", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        sugar.Info("Syslog listener started successfully")
                }</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                sugar.Errorw("CEF listener panicked", "panic", r)
                        }</span>
                }()
                <span class="cov0" title="0">if err := cefListener.Start(); err != nil </span><span class="cov0" title="0">{
                        sugar.Errorw("Failed to start CEF listener", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        sugar.Info("CEF listener started successfully")
                }</span>
        }()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                sugar.Errorw("JSON listener panicked", "panic", r)
                        }</span>
                }()
                <span class="cov0" title="0">if err := jsonListener.Start(); err != nil </span><span class="cov0" title="0">{
                        sugar.Errorw("Failed to start JSON listener", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        sugar.Info("JSON listener started successfully")
                }</span>
        }()

        // Start API server if storage is available
        <span class="cov0" title="0">var apiServer *api.API
        if mongoDB != nil </span><span class="cov0" title="0">{
                apiServer = api.NewAPI(eventStorage, alertStorage, ruleStorage, actionStorage, correlationRuleStorage, cfg, sugar)
                go func() </span><span class="cov0" title="0">{
                        addr := fmt.Sprintf(":%d", cfg.API.Port)
                        sugar.Infof("API server started on %s", addr)
                        if cfg.API.TLS </span><span class="cov0" title="0">{
                                if err := apiServer.StartTLS(addr, cfg.API.CertFile, cfg.API.KeyFile); err != nil </span><span class="cov0" title="0">{
                                        sugar.Fatalf("Failed to start API server with TLS: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if err := apiServer.Start(addr); err != nil </span><span class="cov0" title="0">{
                                        sugar.Fatalf("Failed to start API server: %v", err)
                                }</span>
                        }
                }()
        } else<span class="cov0" title="0"> {
                sugar.Warnf("API server not started: MongoDB is disabled. Enable MongoDB in config to access the web interface on port %d", cfg.API.Port)
        }</span>

        <span class="cov0" title="0">return detector, syslogListener, cefListener, jsonListener, apiServer</span>
}

// shutdownSystem performs graceful shutdown
func shutdownSystem(mongoDB *storage.MongoDB, syslogListener *ingest.SyslogListener, cefListener *ingest.CEFListener, jsonListener *ingest.JSONListener, rawEventCh chan *core.Event, detector *detect.Detector, processedEventCh chan *core.Event, alertCh chan *core.Alert, eventStorage *storage.EventStorage, alertStorage *storage.AlertStorage, retentionManager *storage.RetentionManager, apiServer *api.API, sugar *zap.SugaredLogger) <span class="cov0" title="0">{
        sugar.Info("Shutting down...")

        // Graceful shutdown sequence
        syslogListener.Stop()
        cefListener.Stop()
        jsonListener.Stop()
        close(rawEventCh)

        detector.Stop()

        close(processedEventCh)
        close(alertCh)
        if mongoDB != nil </span><span class="cov0" title="0">{
                eventStorage.Stop()
                alertStorage.Stop()
        }</span>

        <span class="cov0" title="0">if retentionManager != nil </span><span class="cov0" title="0">{
                retentionManager.Stop()
        }</span>

        <span class="cov0" title="0">if apiServer != nil </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                if err := apiServer.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                        sugar.Errorw("Failed to stop API server", "error", err)
                }</span>
        }

        <span class="cov0" title="0">sugar.Info("Shutdown complete")</span>
}

// run initializes and starts the Cerberus SIEM system
func run() error <span class="cov0" title="0">{
        logger, sugar, err := initLogger()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize logger: %w", err)
        }</span>
        <span class="cov0" title="0">defer logger.Sync()

        sugar.Info("Cerberus SIEM starting...")

        cfg, mongoDB, rawEventCh, processedEventCh, alertCh, eventStorage, alertStorage, ruleStorage, actionStorage, correlationRuleStorage, retentionManager, rules, correlationRules, err := initSystem(sugar)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if mongoDB != nil </span><span class="cov0" title="0">{
                defer mongoDB.Close(context.Background())
        }</span>

        <span class="cov0" title="0">detector, syslogListener, cefListener, jsonListener, apiServer := startServices(cfg, mongoDB, rawEventCh, processedEventCh, alertCh, eventStorage, alertStorage, ruleStorage, actionStorage, correlationRuleStorage, rules, correlationRules, sugar)

        // Wait for shutdown signal
        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM)
        &lt;-c

        shutdownSystem(mongoDB, syslogListener, cefListener, jsonListener, rawEventCh, detector, processedEventCh, alertCh, eventStorage, alertStorage, retentionManager, apiServer, sugar)

        return nil</span>
}

// main is the entry point
func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package storage

import (
        "context"
        "errors"
        "fmt"
        "time"

        "cerberus/core"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// ErrActionNotFound is returned when an action is not found
var ErrActionNotFound = errors.New("action not found")

// ActionCursor interface for mocking
type ActionCursor interface {
        All(ctx context.Context, results interface{}) error
        Close(ctx context.Context) error
        Err() error
        Next(ctx context.Context) bool
        Decode(v interface{}) error
}

// ActionSingleResult interface for mocking
type ActionSingleResult interface {
        Decode(v interface{}) error
}

// ActionCollection interface for mocking
type ActionCollection interface {
        Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (ActionCursor, error)
        FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) ActionSingleResult
        InsertOne(ctx context.Context, document interface{}, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error)
        UpdateOne(ctx context.Context, filter interface{}, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error)
        DeleteOne(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error)
        Indexes() mongo.IndexView
}

// mongoActionCursor adapts *mongo.Cursor to ActionCursor
type mongoActionCursor struct {
        *mongo.Cursor
}

func (m *mongoActionCursor) All(ctx context.Context, results interface{}) error <span class="cov0" title="0">{
        return m.Cursor.All(ctx, results)
}</span>

func (m *mongoActionCursor) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.Cursor.Close(ctx)
}</span>

func (m *mongoActionCursor) Err() error <span class="cov0" title="0">{
        return m.Cursor.Err()
}</span>

func (m *mongoActionCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        return m.Cursor.Next(ctx)
}</span>

func (m *mongoActionCursor) Decode(v interface{}) error <span class="cov0" title="0">{
        return m.Cursor.Decode(v)
}</span>

// mongoActionSingleResult adapts *mongo.SingleResult to ActionSingleResult
type mongoActionSingleResult struct {
        *mongo.SingleResult
}

func (m *mongoActionSingleResult) Decode(v interface{}) error <span class="cov0" title="0">{
        return m.SingleResult.Decode(v)
}</span>

// mongoActionCollection adapts *mongo.Collection to ActionCollection
type mongoActionCollection struct {
        *mongo.Collection
}

func (m *mongoActionCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (ActionCursor, error) <span class="cov0" title="0">{
        cursor, err := m.Collection.Find(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mongoActionCursor{Cursor: cursor}, nil</span>
}

func (m *mongoActionCollection) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) ActionSingleResult <span class="cov0" title="0">{
        return &amp;mongoActionSingleResult{SingleResult: m.Collection.FindOne(ctx, filter, opts...)}
}</span>

func (m *mongoActionCollection) Indexes() mongo.IndexView <span class="cov0" title="0">{
        return m.Collection.Indexes()
}</span>

// ActionStorage handles action persistence and retrieval
type ActionStorage struct {
        mongoDB     *MongoDB
        actionsColl ActionCollection
}

// NewActionStorage creates a new action storage handler
func NewActionStorage(mongoDB *MongoDB) *ActionStorage <span class="cov0" title="0">{
        return &amp;ActionStorage{
                mongoDB:     mongoDB,
                actionsColl: &amp;mongoActionCollection{Collection: mongoDB.Database.Collection("actions")},
        }
}</span>

// GetActions retrieves all actions from the database
func (as *ActionStorage) GetActions() ([]core.Action, error) <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        cursor, err := as.actionsColl.Find(ctx, bson.M{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to find actions: %w", err)
        }</span>
        <span class="cov1" title="1">defer cursor.Close(ctx)

        var actions []core.Action
        if err = cursor.All(ctx, &amp;actions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode actions: %w", err)
        }</span>

        <span class="cov1" title="1">return actions, nil</span>
}

// GetAction retrieves a single action by ID
func (as *ActionStorage) GetAction(id string) (*core.Action, error) <span class="cov10" title="6">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        var action core.Action
        err := as.actionsColl.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;action)
        if err != nil </span><span class="cov7" title="4">{
                if err == mongo.ErrNoDocuments </span><span class="cov7" title="4">{
                        return nil, ErrActionNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to find action: %w", err)</span>
        }

        <span class="cov4" title="2">return &amp;action, nil</span>
}

// CreateAction inserts a new action
func (as *ActionStorage) CreateAction(action *core.Action) error <span class="cov6" title="3">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Check if action with same ID exists
        existing, _ := as.GetAction(action.ID)
        if existing != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("action with ID %s already exists", action.ID)
        }</span>

        <span class="cov4" title="2">_, err := as.actionsColl.InsertOne(ctx, action)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to insert action: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// UpdateAction updates an existing action
func (as *ActionStorage) UpdateAction(id string, action *core.Action) error <span class="cov6" title="3">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        filter := bson.M{"_id": id}
        update := bson.M{"$set": action}

        result, err := as.actionsColl.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to update action: %w", err)
        }</span>

        <span class="cov4" title="2">if result.MatchedCount == 0 </span><span class="cov1" title="1">{
                return ErrActionNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DeleteAction deletes an action by ID
func (as *ActionStorage) DeleteAction(id string) error <span class="cov6" title="3">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := as.actionsColl.DeleteOne(ctx, bson.M{"_id": id})
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete action: %w", err)
        }</span>

        <span class="cov4" title="2">if result.DeletedCount == 0 </span><span class="cov1" title="1">{
                return ErrActionNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// EnsureIndexes creates necessary indexes for actions collection
func (as *ActionStorage) EnsureIndexes() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        indexModel := mongo.IndexModel{
                Keys:    bson.M{"_id": 1},
                Options: options.Index().SetUnique(true),
        }

        _, err := as.actionsColl.Indexes().CreateOne(ctx, indexModel)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create index on actions._id: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package storage

import (
        "container/list"
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "sync"
        "time"

        "cerberus/config"
        "cerberus/core"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.uber.org/zap"
)

var ErrAlertNotFound = errors.New("alert not found")

// AlertCursor interface for mocking
type AlertCursor interface {
        All(ctx context.Context, results interface{}) error
        Close(ctx context.Context) error
        Err() error
        Next(ctx context.Context) bool
        Decode(v interface{}) error
}

// AlertSingleResult interface for mocking
type AlertSingleResult interface {
        Decode(v interface{}) error
}

// AlertCollection interface for mocking
type AlertCollection interface {
        Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (AlertCursor, error)
        InsertMany(ctx context.Context, documents []interface{}, opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error)
        UpdateOne(ctx context.Context, filter interface{}, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error)
        CountDocuments(ctx context.Context, filter interface{}, opts ...*options.CountOptions) (int64, error)
        Aggregate(ctx context.Context, pipeline interface{}, opts ...*options.AggregateOptions) (AlertCursor, error)
        DeleteMany(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error)
}

// mongoAlertCursor adapts *mongo.Cursor to AlertCursor
type mongoAlertCursor struct {
        *mongo.Cursor
}

func (m *mongoAlertCursor) All(ctx context.Context, results interface{}) error <span class="cov0" title="0">{
        return m.Cursor.All(ctx, results)
}</span>

func (m *mongoAlertCursor) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.Cursor.Close(ctx)
}</span>

func (m *mongoAlertCursor) Err() error <span class="cov0" title="0">{
        return m.Cursor.Err()
}</span>

func (m *mongoAlertCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        return m.Cursor.Next(ctx)
}</span>

func (m *mongoAlertCursor) Decode(v interface{}) error <span class="cov0" title="0">{
        return m.Cursor.Decode(v)
}</span>

// mongoAlertSingleResult adapts *mongo.SingleResult to AlertSingleResult
type mongoAlertSingleResult struct {
        *mongo.SingleResult
}

func (m *mongoAlertSingleResult) Decode(v interface{}) error <span class="cov0" title="0">{
        return m.SingleResult.Decode(v)
}</span>

// mongoAlertCollection adapts *mongo.Collection to AlertCollection
type mongoAlertCollection struct {
        *mongo.Collection
}

func (m *mongoAlertCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (AlertCursor, error) <span class="cov0" title="0">{
        cursor, err := m.Collection.Find(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mongoAlertCursor{Cursor: cursor}, nil</span>
}

func (m *mongoAlertCollection) Aggregate(ctx context.Context, pipeline interface{}, opts ...*options.AggregateOptions) (AlertCursor, error) <span class="cov0" title="0">{
        cursor, err := m.Collection.Aggregate(ctx, pipeline, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mongoAlertCursor{Cursor: cursor}, nil</span>
}

// AlertStorage handles alert persistence
type AlertStorage struct {
        mongoDB        *MongoDB
        alertsColl     AlertCollection
        dlColl         AlertCollection
        batchSize      int
        alertCh        &lt;-chan *core.Alert
        timeout        time.Duration
        wg             sync.WaitGroup
        dedupCache     map[string]bool
        dedupOrder     *list.List
        dedupOrderMap  map[string]*list.Element
        dedupCacheSize int
        dedupMutex     sync.RWMutex
        logger         *zap.SugaredLogger
}

// NewAlertStorage creates a new alert storage handler
func NewAlertStorage(mongoDB *MongoDB, cfg *config.Config, alertCh &lt;-chan *core.Alert, logger *zap.SugaredLogger) *AlertStorage <span class="cov0" title="0">{
        return &amp;AlertStorage{
                mongoDB:        mongoDB,
                alertsColl:     &amp;mongoAlertCollection{Collection: mongoDB.Database.Collection("alerts")},
                dlColl:         &amp;mongoAlertCollection{Collection: mongoDB.Database.Collection("dead_letter_alerts")},
                batchSize:      cfg.Storage.BufferSize,
                alertCh:        alertCh,
                timeout:        time.Duration(cfg.MongoDB.BatchInsertTimeout) * time.Second,
                dedupCache:     make(map[string]bool),
                dedupOrder:     list.New(),
                dedupOrderMap:  make(map[string]*list.Element),
                dedupCacheSize: cfg.Storage.DedupCacheSize,
                logger:         logger,
        }
}</span>

// Start starts the alert storage workers
func (as *AlertStorage) Start(numWorkers int) <span class="cov0" title="0">{
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov0" title="0">{
                as.wg.Add(1)
                go as.worker()
        }</span>
}

// worker processes alerts from the channel
func (as *AlertStorage) worker() <span class="cov0" title="0">{
        defer as.wg.Done()
        batch := make([]interface{}, 0, as.batchSize)

        for alert := range as.alertCh </span><span class="cov0" title="0">{
                // Deduplication based on rule ID and event ID
                hash := as.hashAlert(alert)
                as.dedupMutex.Lock()
                if _, exists := as.dedupOrderMap[hash]; exists </span><span class="cov0" title="0">{
                        as.dedupMutex.Unlock()
                        continue</span>
                }
                <span class="cov0" title="0">as.dedupCache[hash] = true
                elem := as.dedupOrder.PushBack(hash)
                as.dedupOrderMap[hash] = elem
                // LRU eviction: remove oldest if too large
                if as.dedupOrder.Len() &gt; as.dedupCacheSize </span><span class="cov0" title="0">{
                        front := as.dedupOrder.Front()
                        old := front.Value.(string)
                        delete(as.dedupCache, old)
                        delete(as.dedupOrderMap, old)
                        as.dedupOrder.Remove(front)
                }</span>
                <span class="cov0" title="0">as.dedupMutex.Unlock()

                batch = append(batch, alert)

                if len(batch) &gt;= as.batchSize </span><span class="cov0" title="0">{
                        as.insertBatch(batch)
                        batch = batch[:0]
                }</span>
        }

        // Insert remaining
        <span class="cov0" title="0">if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                as.insertBatch(batch)
        }</span>
}

// hashAlert generates a hash for deduplication
func (as *AlertStorage) hashAlert(alert *core.Alert) string <span class="cov6" title="3">{
        h := sha256.Sum256([]byte(fmt.Sprintf("%s-%s", alert.RuleID, alert.EventID)))
        return fmt.Sprintf("%x", h)
}</span>

// insertBatch inserts a batch of alerts
func (as *AlertStorage) insertBatch(batch []interface{}) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), as.timeout)
        defer cancel()

        _, err := as.alertsColl.InsertMany(ctx, batch)
        if err != nil </span><span class="cov0" title="0">{
                as.logger.Errorf("Failed to insert alert batch: %v", err)
                // Send to dead letter
                as.insertDeadLetter(ctx, batch)
        }</span>
}

// insertDeadLetter inserts failed alerts to dead letter queue
func (as *AlertStorage) insertDeadLetter(ctx context.Context, batch []interface{}) <span class="cov0" title="0">{
        dlDocs := make([]interface{}, len(batch))
        for i, doc := range batch </span><span class="cov0" title="0">{
                dlDocs[i] = bson.M{
                        "failed_at": time.Now(),
                        "document":  doc,
                }
        }</span>
        <span class="cov0" title="0">_, err := as.dlColl.InsertMany(ctx, dlDocs)
        if err != nil </span><span class="cov0" title="0">{
                as.logger.Errorf("Failed to insert alert to dead letter: %v", err)
        }</span>
}

// Stop stops the storage workers
func (as *AlertStorage) Stop() <span class="cov0" title="0">{
        as.wg.Wait()
}</span>

// CleanupOldAlerts deletes alerts older than the specified retention period
func (as *AlertStorage) CleanupOldAlerts(retentionDays int) error <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        cutoff := time.Now().AddDate(0, 0, -retentionDays)
        filter := bson.M{"timestamp": bson.M{"$lt": cutoff}}

        result, err := as.alertsColl.DeleteMany(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete old alerts: %w", err)
        }</span>

        <span class="cov1" title="1">as.logger.Infof("Deleted %d old alerts", result.DeletedCount)
        return nil</span>
}

// AcknowledgeAlert updates an alert status to acknowledged
func (as *AlertStorage) AcknowledgeAlert(alertID string) error <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        filter := bson.M{"alert_id": alertID}
        update := bson.M{"$set": bson.M{"status": "Acknowledged"}}

        result, err := as.alertsColl.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to acknowledge alert: %w", err)
        }</span>

        <span class="cov4" title="2">if result.MatchedCount == 0 </span><span class="cov1" title="1">{
                return ErrAlertNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DismissAlert updates an alert status to dismissed
func (as *AlertStorage) DismissAlert(alertID string) error <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        filter := bson.M{"alert_id": alertID}
        update := bson.M{"$set": bson.M{"status": "Dismissed"}}

        result, err := as.alertsColl.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to dismiss alert: %w", err)
        }</span>

        <span class="cov4" title="2">if result.MatchedCount == 0 </span><span class="cov1" title="1">{
                return ErrAlertNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetAlerts retrieves recent alerts from the database
func (as *AlertStorage) GetAlerts(limit int) ([]core.Alert, error) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        findOptions := options.Find()
        findOptions.SetSort(bson.M{"timestamp": -1})
        findOptions.SetLimit(int64(limit))

        cursor, err := as.alertsColl.Find(ctx, bson.M{}, findOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find alerts: %w", err)
        }</span>
        <span class="cov1" title="1">defer cursor.Close(ctx)

        var alerts []core.Alert
        for cursor.Next(ctx) </span><span class="cov1" title="1">{
                var alert core.Alert
                if err := cursor.Decode(&amp;alert); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode alert: %w", err)
                }</span>
                <span class="cov1" title="1">alerts = append(alerts, alert)</span>
        }

        <span class="cov1" title="1">if err := cursor.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cursor error: %w", err)
        }</span>

        <span class="cov1" title="1">return alerts, nil</span>
}

// GetAlertCount returns the total number of alerts
func (as *AlertStorage) GetAlertCount() (int64, error) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        count, err := as.alertsColl.CountDocuments(ctx, bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count alerts: %w", err)
        }</span>

        <span class="cov1" title="1">return count, nil</span>
}

// GetAlertCountsByMonth returns alert counts grouped by month for the last defaultChartMonths months
func (as *AlertStorage) GetAlertCountsByMonth() ([]map[string]interface{}, error) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Get current time and defaultChartMonths months ago
        now := time.Now()
        sixMonthsAgo := now.AddDate(0, -defaultChartMonths, 0)

        pipeline := mongo.Pipeline{
                bson.D{{Key: "$match", Value: bson.M{"timestamp": bson.M{"$gte": sixMonthsAgo}}}},
                bson.D{{Key: "$group", Value: bson.M{
                        "_id":   bson.M{"$dateToString": bson.M{"format": "%Y-%m", "date": "$timestamp"}},
                        "count": bson.M{"$sum": 1},
                }}},
                bson.D{{Key: "$sort", Value: bson.M{"_id": 1}}},
        }

        cursor, err := as.alertsColl.Aggregate(ctx, pipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to aggregate alerts: %w", err)
        }</span>
        <span class="cov1" title="1">defer cursor.Close(ctx)

        var results []bson.M
        if err = cursor.All(ctx, &amp;results); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode aggregation results: %w", err)
        }</span>

        // Map to the expected format, with month names
        <span class="cov1" title="1">alertData := make([]map[string]interface{}, 0, defaultChartMonths)

        for i := 0; i &lt; defaultChartMonths; i++ </span><span class="cov10" title="6">{
                targetMonth := now.AddDate(0, -(defaultChartMonths-1)+i, 0)
                monthStr := fmt.Sprintf("%d-%02d", targetMonth.Year(), targetMonth.Month())
                name := targetMonth.Month().String()[:3]

                count := 0
                for _, result := range results </span><span class="cov10" title="6">{
                        if id, ok := result["_id"].(string); ok &amp;&amp; id == monthStr </span><span class="cov1" title="1">{
                                if c, ok := result["count"].(int32); ok </span><span class="cov1" title="1">{
                                        count = int(c)
                                }</span>
                                <span class="cov1" title="1">break</span>
                        }
                }

                <span class="cov10" title="6">alertData = append(alertData, map[string]interface{}{
                        "name":   name,
                        "alerts": count,
                })</span>
        }

        <span class="cov1" title="1">return alertData, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package storage

import (
        "context"
        "errors"
        "fmt"
        "time"

        "cerberus/core"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var ErrCorrelationRuleNotFound = errors.New("correlation rule not found")

// CorrelationRuleCursor interface for mocking
type CorrelationRuleCursor interface {
        All(ctx context.Context, results interface{}) error
        Close(ctx context.Context) error
        Err() error
        Next(ctx context.Context) bool
        Decode(v interface{}) error
}

// CorrelationRuleSingleResult interface for mocking
type CorrelationRuleSingleResult interface {
        Decode(v interface{}) error
}

// CorrelationRuleCollection interface for mocking
type CorrelationRuleCollection interface {
        Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (CorrelationRuleCursor, error)
        FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) CorrelationRuleSingleResult
        InsertOne(ctx context.Context, document interface{}, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error)
        UpdateOne(ctx context.Context, filter interface{}, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error)
        DeleteOne(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error)
}

// mongoCorrelationRuleCursor adapts *mongo.Cursor to CorrelationRuleCursor
type mongoCorrelationRuleCursor struct {
        *mongo.Cursor
}

func (m *mongoCorrelationRuleCursor) All(ctx context.Context, results interface{}) error <span class="cov0" title="0">{
        return m.Cursor.All(ctx, results)
}</span>

func (m *mongoCorrelationRuleCursor) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.Cursor.Close(ctx)
}</span>

func (m *mongoCorrelationRuleCursor) Err() error <span class="cov0" title="0">{
        return m.Cursor.Err()
}</span>

func (m *mongoCorrelationRuleCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        return m.Cursor.Next(ctx)
}</span>

func (m *mongoCorrelationRuleCursor) Decode(v interface{}) error <span class="cov0" title="0">{
        return m.Cursor.Decode(v)
}</span>

// mongoCorrelationRuleSingleResult adapts *mongo.SingleResult to CorrelationRuleSingleResult
type mongoCorrelationRuleSingleResult struct {
        *mongo.SingleResult
}

func (m *mongoCorrelationRuleSingleResult) Decode(v interface{}) error <span class="cov0" title="0">{
        return m.SingleResult.Decode(v)
}</span>

// mongoCorrelationRuleCollection adapts *mongo.Collection to CorrelationRuleCollection
type mongoCorrelationRuleCollection struct {
        *mongo.Collection
}

func (m *mongoCorrelationRuleCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (CorrelationRuleCursor, error) <span class="cov0" title="0">{
        cursor, err := m.Collection.Find(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mongoCorrelationRuleCursor{Cursor: cursor}, nil</span>
}

func (m *mongoCorrelationRuleCollection) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) CorrelationRuleSingleResult <span class="cov0" title="0">{
        return &amp;mongoCorrelationRuleSingleResult{SingleResult: m.Collection.FindOne(ctx, filter, opts...)}
}</span>

// CorrelationRuleStorage handles correlation rule persistence and retrieval
type CorrelationRuleStorage struct {
        mongoDB              *MongoDB
        correlationRulesColl CorrelationRuleCollection
}

// NewCorrelationRuleStorage creates a new correlation rule storage handler
func NewCorrelationRuleStorage(mongoDB *MongoDB) *CorrelationRuleStorage <span class="cov0" title="0">{
        return &amp;CorrelationRuleStorage{
                mongoDB:              mongoDB,
                correlationRulesColl: &amp;mongoCorrelationRuleCollection{Collection: mongoDB.Database.Collection("correlation_rules")},
        }
}</span>

// GetCorrelationRules retrieves all correlation rules from the database
func (crs *CorrelationRuleStorage) GetCorrelationRules() ([]core.CorrelationRule, error) <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        cursor, err := crs.correlationRulesColl.Find(ctx, bson.M{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to find correlation rules: %w", err)
        }</span>
        <span class="cov1" title="1">defer cursor.Close(ctx)

        var rules []core.CorrelationRule
        if err = cursor.All(ctx, &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode correlation rules: %w", err)
        }</span>

        <span class="cov1" title="1">return rules, nil</span>
}

// GetCorrelationRule retrieves a single correlation rule by ID
func (crs *CorrelationRuleStorage) GetCorrelationRule(id string) (*core.CorrelationRule, error) <span class="cov10" title="6">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        var rule core.CorrelationRule
        err := crs.correlationRulesColl.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;rule)
        if err != nil </span><span class="cov6" title="3">{
                if err == mongo.ErrNoDocuments </span><span class="cov6" title="3">{
                        return nil, ErrCorrelationRuleNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to find correlation rule: %w", err)</span>
        }

        <span class="cov6" title="3">return &amp;rule, nil</span>
}

// CreateCorrelationRule inserts a new correlation rule
func (crs *CorrelationRuleStorage) CreateCorrelationRule(rule *core.CorrelationRule) error <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Check if rule with same ID exists
        existing, _ := crs.GetCorrelationRule(rule.ID)
        if existing != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("correlation rule with ID %s already exists", rule.ID)
        }</span>

        <span class="cov1" title="1">_, err := crs.correlationRulesColl.InsertOne(ctx, rule)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert correlation rule: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// UpdateCorrelationRule updates an existing correlation rule
func (crs *CorrelationRuleStorage) UpdateCorrelationRule(id string, rule *core.CorrelationRule) error <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Get current rule to increment version
        current, err := crs.GetCorrelationRule(id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">rule.Version = current.Version + 1

        filter := bson.M{"_id": id}
        update := bson.M{"$set": rule}

        result, err := crs.correlationRulesColl.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update correlation rule: %w", err)
        }</span>

        <span class="cov1" title="1">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return ErrCorrelationRuleNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DeleteCorrelationRule deletes a correlation rule by ID
func (crs *CorrelationRuleStorage) DeleteCorrelationRule(id string) error <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := crs.correlationRulesColl.DeleteOne(ctx, bson.M{"_id": id})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete correlation rule: %w", err)
        }</span>

        <span class="cov4" title="2">if result.DeletedCount == 0 </span><span class="cov1" title="1">{
                return ErrCorrelationRuleNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// EnsureIndexes creates necessary indexes for correlation rules collection
func (crs *CorrelationRuleStorage) EnsureIndexes() error <span class="cov1" title="1">{
        // _id is automatically indexed, no need for additional index
        return nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: actionstorage.go

// Package storage is a generated GoMock package.
package storage

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        mongo "go.mongodb.org/mongo-driver/mongo"
        options "go.mongodb.org/mongo-driver/mongo/options"
)

// MockActionCursor is a mock of ActionCursor interface.
type MockActionCursor struct {
        ctrl     *gomock.Controller
        recorder *MockActionCursorMockRecorder
}

// MockActionCursorMockRecorder is the mock recorder for MockActionCursor.
type MockActionCursorMockRecorder struct {
        mock *MockActionCursor
}

// NewMockActionCursor creates a new mock instance.
func NewMockActionCursor(ctrl *gomock.Controller) *MockActionCursor <span class="cov1" title="1">{
        mock := &amp;MockActionCursor{ctrl: ctrl}
        mock.recorder = &amp;MockActionCursorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActionCursor) EXPECT() *MockActionCursorMockRecorder <span class="cov3" title="2">{
        return m.recorder
}</span>

// All mocks base method.
func (m *MockActionCursor) All(ctx context.Context, results interface{}) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "All", ctx, results)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// All indicates an expected call of All.
func (mr *MockActionCursorMockRecorder) All(ctx, results interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockActionCursor)(nil).All), ctx, results)
}</span>

// Close mocks base method.
func (m *MockActionCursor) Close(ctx context.Context) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockActionCursorMockRecorder) Close(ctx interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockActionCursor)(nil).Close), ctx)
}</span>

// Decode mocks base method.
func (m *MockActionCursor) Decode(v interface{}) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockActionCursorMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockActionCursor)(nil).Decode), v)
}</span>

// Err mocks base method.
func (m *MockActionCursor) Err() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Err")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Err indicates an expected call of Err.
func (mr *MockActionCursorMockRecorder) Err() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockActionCursor)(nil).Err))
}</span>

// Next mocks base method.
func (m *MockActionCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Next", ctx)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Next indicates an expected call of Next.
func (mr *MockActionCursorMockRecorder) Next(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockActionCursor)(nil).Next), ctx)
}</span>

// MockActionSingleResult is a mock of ActionSingleResult interface.
type MockActionSingleResult struct {
        ctrl     *gomock.Controller
        recorder *MockActionSingleResultMockRecorder
}

// MockActionSingleResultMockRecorder is the mock recorder for MockActionSingleResult.
type MockActionSingleResultMockRecorder struct {
        mock *MockActionSingleResult
}

// NewMockActionSingleResult creates a new mock instance.
func NewMockActionSingleResult(ctrl *gomock.Controller) *MockActionSingleResult <span class="cov6" title="6">{
        mock := &amp;MockActionSingleResult{ctrl: ctrl}
        mock.recorder = &amp;MockActionSingleResultMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActionSingleResult) EXPECT() *MockActionSingleResultMockRecorder <span class="cov6" title="6">{
        return m.recorder
}</span>

// Decode mocks base method.
func (m *MockActionSingleResult) Decode(v interface{}) error <span class="cov6" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockActionSingleResultMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov6" title="6">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockActionSingleResult)(nil).Decode), v)
}</span>

// MockActionCollection is a mock of ActionCollection interface.
type MockActionCollection struct {
        ctrl     *gomock.Controller
        recorder *MockActionCollectionMockRecorder
}

// MockActionCollectionMockRecorder is the mock recorder for MockActionCollection.
type MockActionCollectionMockRecorder struct {
        mock *MockActionCollection
}

// NewMockActionCollection creates a new mock instance.
func NewMockActionCollection(ctrl *gomock.Controller) *MockActionCollection <span class="cov9" title="14">{
        mock := &amp;MockActionCollection{ctrl: ctrl}
        mock.recorder = &amp;MockActionCollectionMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActionCollection) EXPECT() *MockActionCollectionMockRecorder <span class="cov10" title="16">{
        return m.recorder
}</span>

// DeleteOne mocks base method.
func (m *MockActionCollection) DeleteOne(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) <span class="cov4" title="3">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov4" title="3">ret := m.ctrl.Call(m, "DeleteOne", varargs...)
        ret0, _ := ret[0].(*mongo.DeleteResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteOne indicates an expected call of DeleteOne.
func (mr *MockActionCollectionMockRecorder) DeleteOne(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov4" title="3">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOne", reflect.TypeOf((*MockActionCollection)(nil).DeleteOne), varargs...)
}</span>

// Find mocks base method.
func (m *MockActionCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (ActionCursor, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "Find", varargs...)
        ret0, _ := ret[0].(ActionCursor)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Find indicates an expected call of Find.
func (mr *MockActionCollectionMockRecorder) Find(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockActionCollection)(nil).Find), varargs...)
}</span>

// FindOne mocks base method.
func (m *MockActionCollection) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) ActionSingleResult <span class="cov6" title="6">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov6" title="6">ret := m.ctrl.Call(m, "FindOne", varargs...)
        ret0, _ := ret[0].(ActionSingleResult)
        return ret0</span>
}

// FindOne indicates an expected call of FindOne.
func (mr *MockActionCollectionMockRecorder) FindOne(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov6" title="6">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockActionCollection)(nil).FindOne), varargs...)
}</span>

// Indexes mocks base method.
func (m *MockActionCollection) Indexes() mongo.IndexView <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Indexes")
        ret0, _ := ret[0].(mongo.IndexView)
        return ret0
}</span>

// Indexes indicates an expected call of Indexes.
func (mr *MockActionCollectionMockRecorder) Indexes() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Indexes", reflect.TypeOf((*MockActionCollection)(nil).Indexes))
}</span>

// InsertOne mocks base method.
func (m *MockActionCollection) InsertOne(ctx context.Context, document interface{}, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, document}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "InsertOne", varargs...)
        ret0, _ := ret[0].(*mongo.InsertOneResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// InsertOne indicates an expected call of InsertOne.
func (mr *MockActionCollectionMockRecorder) InsertOne(ctx, document interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, document}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockActionCollection)(nil).InsertOne), varargs...)
}</span>

// UpdateOne mocks base method.
func (m *MockActionCollection) UpdateOne(ctx context.Context, filter, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov4" title="3">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter, update}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov4" title="3">ret := m.ctrl.Call(m, "UpdateOne", varargs...)
        ret0, _ := ret[0].(*mongo.UpdateResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockActionCollectionMockRecorder) UpdateOne(ctx, filter, update interface{}, opts ...interface{}) *gomock.Call <span class="cov4" title="3">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter, update}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockActionCollection)(nil).UpdateOne), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: alertstorage.go

// Package storage is a generated GoMock package.
package storage

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        mongo "go.mongodb.org/mongo-driver/mongo"
        options "go.mongodb.org/mongo-driver/mongo/options"
)

// MockAlertCursor is a mock of AlertCursor interface.
type MockAlertCursor struct {
        ctrl     *gomock.Controller
        recorder *MockAlertCursorMockRecorder
}

// MockAlertCursorMockRecorder is the mock recorder for MockAlertCursor.
type MockAlertCursorMockRecorder struct {
        mock *MockAlertCursor
}

// NewMockAlertCursor creates a new mock instance.
func NewMockAlertCursor(ctrl *gomock.Controller) *MockAlertCursor <span class="cov4" title="2">{
        mock := &amp;MockAlertCursor{ctrl: ctrl}
        mock.recorder = &amp;MockAlertCursorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAlertCursor) EXPECT() *MockAlertCursorMockRecorder <span class="cov9" title="7">{
        return m.recorder
}</span>

// All mocks base method.
func (m *MockAlertCursor) All(ctx context.Context, results interface{}) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "All", ctx, results)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// All indicates an expected call of All.
func (mr *MockAlertCursorMockRecorder) All(ctx, results interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockAlertCursor)(nil).All), ctx, results)
}</span>

// Close mocks base method.
func (m *MockAlertCursor) Close(ctx context.Context) error <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockAlertCursorMockRecorder) Close(ctx interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockAlertCursor)(nil).Close), ctx)
}</span>

// Decode mocks base method.
func (m *MockAlertCursor) Decode(v interface{}) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockAlertCursorMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockAlertCursor)(nil).Decode), v)
}</span>

// Err mocks base method.
func (m *MockAlertCursor) Err() error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Err")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Err indicates an expected call of Err.
func (mr *MockAlertCursorMockRecorder) Err() *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockAlertCursor)(nil).Err))
}</span>

// Next mocks base method.
func (m *MockAlertCursor) Next(ctx context.Context) bool <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Next", ctx)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Next indicates an expected call of Next.
func (mr *MockAlertCursorMockRecorder) Next(ctx interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockAlertCursor)(nil).Next), ctx)
}</span>

// MockAlertSingleResult is a mock of AlertSingleResult interface.
type MockAlertSingleResult struct {
        ctrl     *gomock.Controller
        recorder *MockAlertSingleResultMockRecorder
}

// MockAlertSingleResultMockRecorder is the mock recorder for MockAlertSingleResult.
type MockAlertSingleResultMockRecorder struct {
        mock *MockAlertSingleResult
}

// NewMockAlertSingleResult creates a new mock instance.
func NewMockAlertSingleResult(ctrl *gomock.Controller) *MockAlertSingleResult <span class="cov0" title="0">{
        mock := &amp;MockAlertSingleResult{ctrl: ctrl}
        mock.recorder = &amp;MockAlertSingleResultMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAlertSingleResult) EXPECT() *MockAlertSingleResultMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Decode mocks base method.
func (m *MockAlertSingleResult) Decode(v interface{}) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockAlertSingleResultMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockAlertSingleResult)(nil).Decode), v)
}</span>

// MockAlertCollection is a mock of AlertCollection interface.
type MockAlertCollection struct {
        ctrl     *gomock.Controller
        recorder *MockAlertCollectionMockRecorder
}

// MockAlertCollectionMockRecorder is the mock recorder for MockAlertCollection.
type MockAlertCollectionMockRecorder struct {
        mock *MockAlertCollection
}

// NewMockAlertCollection creates a new mock instance.
func NewMockAlertCollection(ctrl *gomock.Controller) *MockAlertCollection <span class="cov10" title="8">{
        mock := &amp;MockAlertCollection{ctrl: ctrl}
        mock.recorder = &amp;MockAlertCollectionMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAlertCollection) EXPECT() *MockAlertCollectionMockRecorder <span class="cov10" title="8">{
        return m.recorder
}</span>

// Aggregate mocks base method.
func (m *MockAlertCollection) Aggregate(ctx context.Context, pipeline interface{}, opts ...*options.AggregateOptions) (AlertCursor, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, pipeline}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "Aggregate", varargs...)
        ret0, _ := ret[0].(AlertCursor)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockAlertCollectionMockRecorder) Aggregate(ctx, pipeline interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, pipeline}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockAlertCollection)(nil).Aggregate), varargs...)
}</span>

// CountDocuments mocks base method.
func (m *MockAlertCollection) CountDocuments(ctx context.Context, filter interface{}, opts ...*options.CountOptions) (int64, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "CountDocuments", varargs...)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CountDocuments indicates an expected call of CountDocuments.
func (mr *MockAlertCollectionMockRecorder) CountDocuments(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountDocuments", reflect.TypeOf((*MockAlertCollection)(nil).CountDocuments), varargs...)
}</span>

// DeleteMany mocks base method.
func (m *MockAlertCollection) DeleteMany(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "DeleteMany", varargs...)
        ret0, _ := ret[0].(*mongo.DeleteResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteMany indicates an expected call of DeleteMany.
func (mr *MockAlertCollectionMockRecorder) DeleteMany(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMany", reflect.TypeOf((*MockAlertCollection)(nil).DeleteMany), varargs...)
}</span>

// Find mocks base method.
func (m *MockAlertCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (AlertCursor, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov1" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "Find", varargs...)
        ret0, _ := ret[0].(AlertCursor)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Find indicates an expected call of Find.
func (mr *MockAlertCollectionMockRecorder) Find(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockAlertCollection)(nil).Find), varargs...)
}</span>

// InsertMany mocks base method.
func (m *MockAlertCollection) InsertMany(ctx context.Context, documents []interface{}, opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, documents}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "InsertMany", varargs...)
        ret0, _ := ret[0].(*mongo.InsertManyResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// InsertMany indicates an expected call of InsertMany.
func (mr *MockAlertCollectionMockRecorder) InsertMany(ctx, documents interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, documents}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMany", reflect.TypeOf((*MockAlertCollection)(nil).InsertMany), varargs...)
}</span>

// UpdateOne mocks base method.
func (m *MockAlertCollection) UpdateOne(ctx context.Context, filter, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov7" title="4">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter, update}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov7" title="4">ret := m.ctrl.Call(m, "UpdateOne", varargs...)
        ret0, _ := ret[0].(*mongo.UpdateResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockAlertCollectionMockRecorder) UpdateOne(ctx, filter, update interface{}, opts ...interface{}) *gomock.Call <span class="cov7" title="4">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter, update}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockAlertCollection)(nil).UpdateOne), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: correlationrulestorage.go

// Package storage is a generated GoMock package.
package storage

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        mongo "go.mongodb.org/mongo-driver/mongo"
        options "go.mongodb.org/mongo-driver/mongo/options"
)

// MockCorrelationRuleCursor is a mock of CorrelationRuleCursor interface.
type MockCorrelationRuleCursor struct {
        ctrl     *gomock.Controller
        recorder *MockCorrelationRuleCursorMockRecorder
}

// MockCorrelationRuleCursorMockRecorder is the mock recorder for MockCorrelationRuleCursor.
type MockCorrelationRuleCursorMockRecorder struct {
        mock *MockCorrelationRuleCursor
}

// NewMockCorrelationRuleCursor creates a new mock instance.
func NewMockCorrelationRuleCursor(ctrl *gomock.Controller) *MockCorrelationRuleCursor <span class="cov1" title="1">{
        mock := &amp;MockCorrelationRuleCursor{ctrl: ctrl}
        mock.recorder = &amp;MockCorrelationRuleCursorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCorrelationRuleCursor) EXPECT() *MockCorrelationRuleCursorMockRecorder <span class="cov3" title="2">{
        return m.recorder
}</span>

// All mocks base method.
func (m *MockCorrelationRuleCursor) All(ctx context.Context, results interface{}) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "All", ctx, results)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// All indicates an expected call of All.
func (mr *MockCorrelationRuleCursorMockRecorder) All(ctx, results interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockCorrelationRuleCursor)(nil).All), ctx, results)
}</span>

// Close mocks base method.
func (m *MockCorrelationRuleCursor) Close(ctx context.Context) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockCorrelationRuleCursorMockRecorder) Close(ctx interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockCorrelationRuleCursor)(nil).Close), ctx)
}</span>

// Decode mocks base method.
func (m *MockCorrelationRuleCursor) Decode(v interface{}) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockCorrelationRuleCursorMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockCorrelationRuleCursor)(nil).Decode), v)
}</span>

// Err mocks base method.
func (m *MockCorrelationRuleCursor) Err() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Err")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Err indicates an expected call of Err.
func (mr *MockCorrelationRuleCursorMockRecorder) Err() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockCorrelationRuleCursor)(nil).Err))
}</span>

// Next mocks base method.
func (m *MockCorrelationRuleCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Next", ctx)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Next indicates an expected call of Next.
func (mr *MockCorrelationRuleCursorMockRecorder) Next(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockCorrelationRuleCursor)(nil).Next), ctx)
}</span>

// MockCorrelationRuleSingleResult is a mock of CorrelationRuleSingleResult interface.
type MockCorrelationRuleSingleResult struct {
        ctrl     *gomock.Controller
        recorder *MockCorrelationRuleSingleResultMockRecorder
}

// MockCorrelationRuleSingleResultMockRecorder is the mock recorder for MockCorrelationRuleSingleResult.
type MockCorrelationRuleSingleResultMockRecorder struct {
        mock *MockCorrelationRuleSingleResult
}

// NewMockCorrelationRuleSingleResult creates a new mock instance.
func NewMockCorrelationRuleSingleResult(ctrl *gomock.Controller) *MockCorrelationRuleSingleResult <span class="cov7" title="6">{
        mock := &amp;MockCorrelationRuleSingleResult{ctrl: ctrl}
        mock.recorder = &amp;MockCorrelationRuleSingleResultMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCorrelationRuleSingleResult) EXPECT() *MockCorrelationRuleSingleResultMockRecorder <span class="cov7" title="6">{
        return m.recorder
}</span>

// Decode mocks base method.
func (m *MockCorrelationRuleSingleResult) Decode(v interface{}) error <span class="cov7" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockCorrelationRuleSingleResultMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov7" title="6">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockCorrelationRuleSingleResult)(nil).Decode), v)
}</span>

// MockCorrelationRuleCollection is a mock of CorrelationRuleCollection interface.
type MockCorrelationRuleCollection struct {
        ctrl     *gomock.Controller
        recorder *MockCorrelationRuleCollectionMockRecorder
}

// MockCorrelationRuleCollectionMockRecorder is the mock recorder for MockCorrelationRuleCollection.
type MockCorrelationRuleCollectionMockRecorder struct {
        mock *MockCorrelationRuleCollection
}

// NewMockCorrelationRuleCollection creates a new mock instance.
func NewMockCorrelationRuleCollection(ctrl *gomock.Controller) *MockCorrelationRuleCollection <span class="cov9" title="10">{
        mock := &amp;MockCorrelationRuleCollection{ctrl: ctrl}
        mock.recorder = &amp;MockCorrelationRuleCollectionMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCorrelationRuleCollection) EXPECT() *MockCorrelationRuleCollectionMockRecorder <span class="cov10" title="12">{
        return m.recorder
}</span>

// DeleteOne mocks base method.
func (m *MockCorrelationRuleCollection) DeleteOne(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "DeleteOne", varargs...)
        ret0, _ := ret[0].(*mongo.DeleteResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteOne indicates an expected call of DeleteOne.
func (mr *MockCorrelationRuleCollectionMockRecorder) DeleteOne(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOne", reflect.TypeOf((*MockCorrelationRuleCollection)(nil).DeleteOne), varargs...)
}</span>

// Find mocks base method.
func (m *MockCorrelationRuleCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (CorrelationRuleCursor, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "Find", varargs...)
        ret0, _ := ret[0].(CorrelationRuleCursor)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Find indicates an expected call of Find.
func (mr *MockCorrelationRuleCollectionMockRecorder) Find(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockCorrelationRuleCollection)(nil).Find), varargs...)
}</span>

// FindOne mocks base method.
func (m *MockCorrelationRuleCollection) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) CorrelationRuleSingleResult <span class="cov7" title="6">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov7" title="6">ret := m.ctrl.Call(m, "FindOne", varargs...)
        ret0, _ := ret[0].(CorrelationRuleSingleResult)
        return ret0</span>
}

// FindOne indicates an expected call of FindOne.
func (mr *MockCorrelationRuleCollectionMockRecorder) FindOne(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov7" title="6">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockCorrelationRuleCollection)(nil).FindOne), varargs...)
}</span>

// InsertOne mocks base method.
func (m *MockCorrelationRuleCollection) InsertOne(ctx context.Context, document interface{}, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, document}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "InsertOne", varargs...)
        ret0, _ := ret[0].(*mongo.InsertOneResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// InsertOne indicates an expected call of InsertOne.
func (mr *MockCorrelationRuleCollectionMockRecorder) InsertOne(ctx, document interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, document}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockCorrelationRuleCollection)(nil).InsertOne), varargs...)
}</span>

// UpdateOne mocks base method.
func (m *MockCorrelationRuleCollection) UpdateOne(ctx context.Context, filter, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter, update}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "UpdateOne", varargs...)
        ret0, _ := ret[0].(*mongo.UpdateResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockCorrelationRuleCollectionMockRecorder) UpdateOne(ctx, filter, update interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter, update}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockCorrelationRuleCollection)(nil).UpdateOne), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: rulestorage.go

// Package storage is a generated GoMock package.
package storage

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        mongo "go.mongodb.org/mongo-driver/mongo"
        options "go.mongodb.org/mongo-driver/mongo/options"
)

// MockRuleCursor is a mock of RuleCursor interface.
type MockRuleCursor struct {
        ctrl     *gomock.Controller
        recorder *MockRuleCursorMockRecorder
}

// MockRuleCursorMockRecorder is the mock recorder for MockRuleCursor.
type MockRuleCursorMockRecorder struct {
        mock *MockRuleCursor
}

// NewMockRuleCursor creates a new mock instance.
func NewMockRuleCursor(ctrl *gomock.Controller) *MockRuleCursor <span class="cov1" title="1">{
        mock := &amp;MockRuleCursor{ctrl: ctrl}
        mock.recorder = &amp;MockRuleCursorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuleCursor) EXPECT() *MockRuleCursorMockRecorder <span class="cov3" title="2">{
        return m.recorder
}</span>

// All mocks base method.
func (m *MockRuleCursor) All(ctx context.Context, results interface{}) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "All", ctx, results)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// All indicates an expected call of All.
func (mr *MockRuleCursorMockRecorder) All(ctx, results interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockRuleCursor)(nil).All), ctx, results)
}</span>

// Close mocks base method.
func (m *MockRuleCursor) Close(ctx context.Context) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockRuleCursorMockRecorder) Close(ctx interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRuleCursor)(nil).Close), ctx)
}</span>

// Err mocks base method.
func (m *MockRuleCursor) Err() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Err")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Err indicates an expected call of Err.
func (mr *MockRuleCursorMockRecorder) Err() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockRuleCursor)(nil).Err))
}</span>

// MockRuleSingleResult is a mock of RuleSingleResult interface.
type MockRuleSingleResult struct {
        ctrl     *gomock.Controller
        recorder *MockRuleSingleResultMockRecorder
}

// MockRuleSingleResultMockRecorder is the mock recorder for MockRuleSingleResult.
type MockRuleSingleResultMockRecorder struct {
        mock *MockRuleSingleResult
}

// NewMockRuleSingleResult creates a new mock instance.
func NewMockRuleSingleResult(ctrl *gomock.Controller) *MockRuleSingleResult <span class="cov7" title="6">{
        mock := &amp;MockRuleSingleResult{ctrl: ctrl}
        mock.recorder = &amp;MockRuleSingleResultMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuleSingleResult) EXPECT() *MockRuleSingleResultMockRecorder <span class="cov7" title="6">{
        return m.recorder
}</span>

// Decode mocks base method.
func (m *MockRuleSingleResult) Decode(v interface{}) error <span class="cov7" title="6">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockRuleSingleResultMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov7" title="6">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockRuleSingleResult)(nil).Decode), v)
}</span>

// MockRuleCollection is a mock of RuleCollection interface.
type MockRuleCollection struct {
        ctrl     *gomock.Controller
        recorder *MockRuleCollectionMockRecorder
}

// MockRuleCollectionMockRecorder is the mock recorder for MockRuleCollection.
type MockRuleCollectionMockRecorder struct {
        mock *MockRuleCollection
}

// NewMockRuleCollection creates a new mock instance.
func NewMockRuleCollection(ctrl *gomock.Controller) *MockRuleCollection <span class="cov9" title="10">{
        mock := &amp;MockRuleCollection{ctrl: ctrl}
        mock.recorder = &amp;MockRuleCollectionMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuleCollection) EXPECT() *MockRuleCollectionMockRecorder <span class="cov10" title="12">{
        return m.recorder
}</span>

// DeleteOne mocks base method.
func (m *MockRuleCollection) DeleteOne(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "DeleteOne", varargs...)
        ret0, _ := ret[0].(*mongo.DeleteResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteOne indicates an expected call of DeleteOne.
func (mr *MockRuleCollectionMockRecorder) DeleteOne(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOne", reflect.TypeOf((*MockRuleCollection)(nil).DeleteOne), varargs...)
}</span>

// Find mocks base method.
func (m *MockRuleCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (RuleCursor, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov3" title="2">ret := m.ctrl.Call(m, "Find", varargs...)
        ret0, _ := ret[0].(RuleCursor)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Find indicates an expected call of Find.
func (mr *MockRuleCollectionMockRecorder) Find(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockRuleCollection)(nil).Find), varargs...)
}</span>

// FindOne mocks base method.
func (m *MockRuleCollection) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) RuleSingleResult <span class="cov7" title="6">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov7" title="6">ret := m.ctrl.Call(m, "FindOne", varargs...)
        ret0, _ := ret[0].(RuleSingleResult)
        return ret0</span>
}

// FindOne indicates an expected call of FindOne.
func (mr *MockRuleCollectionMockRecorder) FindOne(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov7" title="6">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockRuleCollection)(nil).FindOne), varargs...)
}</span>

// InsertOne mocks base method.
func (m *MockRuleCollection) InsertOne(ctx context.Context, document interface{}, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, document}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "InsertOne", varargs...)
        ret0, _ := ret[0].(*mongo.InsertOneResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// InsertOne indicates an expected call of InsertOne.
func (mr *MockRuleCollectionMockRecorder) InsertOne(ctx, document interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, document}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOne", reflect.TypeOf((*MockRuleCollection)(nil).InsertOne), varargs...)
}</span>

// UpdateOne mocks base method.
func (m *MockRuleCollection) UpdateOne(ctx context.Context, filter, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter, update}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "UpdateOne", varargs...)
        ret0, _ := ret[0].(*mongo.UpdateResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockRuleCollectionMockRecorder) UpdateOne(ctx, filter, update interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter, update}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockRuleCollection)(nil).UpdateOne), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: mongodb.go

// Package storage is a generated GoMock package.
package storage

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        mongo "go.mongodb.org/mongo-driver/mongo"
        options "go.mongodb.org/mongo-driver/mongo/options"
)

// MockEventCursor is a mock of EventCursor interface.
type MockEventCursor struct {
        ctrl     *gomock.Controller
        recorder *MockEventCursorMockRecorder
}

// MockEventCursorMockRecorder is the mock recorder for MockEventCursor.
type MockEventCursorMockRecorder struct {
        mock *MockEventCursor
}

// NewMockEventCursor creates a new mock instance.
func NewMockEventCursor(ctrl *gomock.Controller) *MockEventCursor <span class="cov4" title="2">{
        mock := &amp;MockEventCursor{ctrl: ctrl}
        mock.recorder = &amp;MockEventCursorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventCursor) EXPECT() *MockEventCursorMockRecorder <span class="cov10" title="7">{
        return m.recorder
}</span>

// All mocks base method.
func (m *MockEventCursor) All(ctx context.Context, results interface{}) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "All", ctx, results)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// All indicates an expected call of All.
func (mr *MockEventCursorMockRecorder) All(ctx, results interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "All", reflect.TypeOf((*MockEventCursor)(nil).All), ctx, results)
}</span>

// Close mocks base method.
func (m *MockEventCursor) Close(ctx context.Context) error <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Close", ctx)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Close indicates an expected call of Close.
func (mr *MockEventCursorMockRecorder) Close(ctx interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEventCursor)(nil).Close), ctx)
}</span>

// Decode mocks base method.
func (m *MockEventCursor) Decode(v interface{}) error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockEventCursorMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockEventCursor)(nil).Decode), v)
}</span>

// Err mocks base method.
func (m *MockEventCursor) Err() error <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Err")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Err indicates an expected call of Err.
func (mr *MockEventCursorMockRecorder) Err() *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockEventCursor)(nil).Err))
}</span>

// Next mocks base method.
func (m *MockEventCursor) Next(ctx context.Context) bool <span class="cov4" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Next", ctx)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Next indicates an expected call of Next.
func (mr *MockEventCursorMockRecorder) Next(ctx interface{}) *gomock.Call <span class="cov4" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockEventCursor)(nil).Next), ctx)
}</span>

// MockEventSingleResult is a mock of EventSingleResult interface.
type MockEventSingleResult struct {
        ctrl     *gomock.Controller
        recorder *MockEventSingleResultMockRecorder
}

// MockEventSingleResultMockRecorder is the mock recorder for MockEventSingleResult.
type MockEventSingleResultMockRecorder struct {
        mock *MockEventSingleResult
}

// NewMockEventSingleResult creates a new mock instance.
func NewMockEventSingleResult(ctrl *gomock.Controller) *MockEventSingleResult <span class="cov0" title="0">{
        mock := &amp;MockEventSingleResult{ctrl: ctrl}
        mock.recorder = &amp;MockEventSingleResultMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventSingleResult) EXPECT() *MockEventSingleResultMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Decode mocks base method.
func (m *MockEventSingleResult) Decode(v interface{}) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Decode", v)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Decode indicates an expected call of Decode.
func (mr *MockEventSingleResultMockRecorder) Decode(v interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockEventSingleResult)(nil).Decode), v)
}</span>

// MockEventCollection is a mock of EventCollection interface.
type MockEventCollection struct {
        ctrl     *gomock.Controller
        recorder *MockEventCollectionMockRecorder
}

// MockEventCollectionMockRecorder is the mock recorder for MockEventCollection.
type MockEventCollectionMockRecorder struct {
        mock *MockEventCollection
}

// NewMockEventCollection creates a new mock instance.
func NewMockEventCollection(ctrl *gomock.Controller) *MockEventCollection <span class="cov7" title="4">{
        mock := &amp;MockEventCollection{ctrl: ctrl}
        mock.recorder = &amp;MockEventCollectionMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventCollection) EXPECT() *MockEventCollectionMockRecorder <span class="cov7" title="4">{
        return m.recorder
}</span>

// Aggregate mocks base method.
func (m *MockEventCollection) Aggregate(ctx context.Context, pipeline interface{}, opts ...*options.AggregateOptions) (EventCursor, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, pipeline}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "Aggregate", varargs...)
        ret0, _ := ret[0].(EventCursor)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockEventCollectionMockRecorder) Aggregate(ctx, pipeline interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, pipeline}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockEventCollection)(nil).Aggregate), varargs...)
}</span>

// CountDocuments mocks base method.
func (m *MockEventCollection) CountDocuments(ctx context.Context, filter interface{}, opts ...*options.CountOptions) (int64, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "CountDocuments", varargs...)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CountDocuments indicates an expected call of CountDocuments.
func (mr *MockEventCollectionMockRecorder) CountDocuments(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountDocuments", reflect.TypeOf((*MockEventCollection)(nil).CountDocuments), varargs...)
}</span>

// DeleteMany mocks base method.
func (m *MockEventCollection) DeleteMany(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "DeleteMany", varargs...)
        ret0, _ := ret[0].(*mongo.DeleteResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteMany indicates an expected call of DeleteMany.
func (mr *MockEventCollectionMockRecorder) DeleteMany(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMany", reflect.TypeOf((*MockEventCollection)(nil).DeleteMany), varargs...)
}</span>

// Find mocks base method.
func (m *MockEventCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (EventCursor, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, filter}
        for _, a := range opts </span><span class="cov1" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov1" title="1">ret := m.ctrl.Call(m, "Find", varargs...)
        ret0, _ := ret[0].(EventCursor)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Find indicates an expected call of Find.
func (mr *MockEventCollectionMockRecorder) Find(ctx, filter interface{}, opts ...interface{}) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, filter}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockEventCollection)(nil).Find), varargs...)
}</span>

// InsertMany mocks base method.
func (m *MockEventCollection) InsertMany(ctx context.Context, documents []interface{}, opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, documents}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "InsertMany", varargs...)
        ret0, _ := ret[0].(*mongo.InsertManyResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// InsertMany indicates an expected call of InsertMany.
func (mr *MockEventCollectionMockRecorder) InsertMany(ctx, documents interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, documents}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMany", reflect.TypeOf((*MockEventCollection)(nil).InsertMany), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package storage

import (
        "container/list"
        "context"
        "crypto/sha256"
        "fmt"
        "sync"
        "time"

        "cerberus/config"
        "cerberus/core"
        "cerberus/metrics"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.uber.org/zap"
)

const defaultChartMonths = 6

// EventCursor interface for mocking
type EventCursor interface {
        All(ctx context.Context, results interface{}) error
        Close(ctx context.Context) error
        Err() error
        Next(ctx context.Context) bool
        Decode(v interface{}) error
}

// EventSingleResult interface for mocking
type EventSingleResult interface {
        Decode(v interface{}) error
}

// EventCollection interface for mocking
type EventCollection interface {
        Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (EventCursor, error)
        InsertMany(ctx context.Context, documents []interface{}, opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error)
        Aggregate(ctx context.Context, pipeline interface{}, opts ...*options.AggregateOptions) (EventCursor, error)
        DeleteMany(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error)
        CountDocuments(ctx context.Context, filter interface{}, opts ...*options.CountOptions) (int64, error)
}

// mongoEventCursor adapts *mongo.Cursor to EventCursor
type mongoEventCursor struct {
        *mongo.Cursor
}

func (m *mongoEventCursor) All(ctx context.Context, results interface{}) error <span class="cov0" title="0">{
        return m.Cursor.All(ctx, results)
}</span>

func (m *mongoEventCursor) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.Cursor.Close(ctx)
}</span>

func (m *mongoEventCursor) Err() error <span class="cov0" title="0">{
        return m.Cursor.Err()
}</span>

func (m *mongoEventCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        return m.Cursor.Next(ctx)
}</span>

func (m *mongoEventCursor) Decode(v interface{}) error <span class="cov0" title="0">{
        return m.Cursor.Decode(v)
}</span>

// mongoEventCollection adapts *mongo.Collection to EventCollection
type mongoEventCollection struct {
        *mongo.Collection
}

func (m *mongoEventCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (EventCursor, error) <span class="cov0" title="0">{
        cursor, err := m.Collection.Find(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mongoEventCursor{Cursor: cursor}, nil</span>
}

func (m *mongoEventCollection) Aggregate(ctx context.Context, pipeline interface{}, opts ...*options.AggregateOptions) (EventCursor, error) <span class="cov0" title="0">{
        cursor, err := m.Collection.Aggregate(ctx, pipeline, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mongoEventCursor{Cursor: cursor}, nil</span>
}

// MongoDB holds the MongoDB client and database
type MongoDB struct {
        Client   *mongo.Client
        Database *mongo.Database
}

// NewMongoDB creates a new MongoDB connection
func NewMongoDB(uri, dbName string, maxPoolSize uint64, logger *zap.SugaredLogger) (*MongoDB, error) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        clientOptions := options.Client().ApplyURI(uri).SetMaxPoolSize(maxPoolSize)
        client, err := mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
        }</span>

        // Ping to verify connection
        <span class="cov0" title="0">if err := client.Ping(ctx, nil); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping MongoDB: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Connected to MongoDB successfully")

        return &amp;MongoDB{
                Client:   client,
                Database: client.Database(dbName),
        }, nil</span>
}

// HealthCheck performs a health check on the MongoDB connection
func (m *MongoDB) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        return m.Client.Ping(ctx, nil)
}</span>

// Close closes the MongoDB connection
func (m *MongoDB) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.Client.Disconnect(ctx)
}</span>

// EventStorage handles event persistence
type EventStorage struct {
        mongoDB             *MongoDB
        EventsColl          EventCollection
        dlColl              EventCollection
        batchSize           int
        eventCh             &lt;-chan *core.Event
        timeout             time.Duration
        wg                  sync.WaitGroup
        dedupCache          map[string]bool
        dedupKeys           *list.List
        dedupCacheSize      int
        dedupEvictionSize   int
        dedupMutex          sync.RWMutex
        enableDeduplication bool
        logger              *zap.SugaredLogger
}

// NewEventStorage creates a new event storage handler
func NewEventStorage(mongoDB *MongoDB, cfg *config.Config, eventCh &lt;-chan *core.Event, logger *zap.SugaredLogger) *EventStorage <span class="cov0" title="0">{
        return &amp;EventStorage{
                mongoDB:             mongoDB,
                EventsColl:          &amp;mongoEventCollection{Collection: mongoDB.Database.Collection("events")},
                dlColl:              &amp;mongoEventCollection{Collection: mongoDB.Database.Collection("dead_letter_events")},
                batchSize:           cfg.Storage.BufferSize,
                eventCh:             eventCh,
                timeout:             time.Duration(cfg.MongoDB.BatchInsertTimeout) * time.Second,
                dedupCache:          make(map[string]bool),
                dedupKeys:           list.New(),
                dedupCacheSize:      cfg.Storage.DedupCacheSize,
                dedupEvictionSize:   cfg.Storage.DedupEvictionSize,
                enableDeduplication: cfg.Storage.Deduplication,
                logger:              logger,
        }
}</span>

// Start starts the event storage workers
func (es *EventStorage) Start(numWorkers int) <span class="cov0" title="0">{
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov0" title="0">{
                es.wg.Add(1)
                go es.worker()
        }</span>
}

// worker processes events from the channel
func (es *EventStorage) worker() <span class="cov0" title="0">{
        defer es.wg.Done()
        batch := make([]interface{}, 0, es.batchSize)

        for event := range es.eventCh </span><span class="cov0" title="0">{
                if es.enableDeduplication </span><span class="cov0" title="0">{
                        // Deduplication
                        hash := es.hashEvent(event)
                        es.dedupMutex.Lock()
                        if es.dedupCache[hash] </span><span class="cov0" title="0">{
                                es.dedupMutex.Unlock()
                                continue</span>
                        }
                        <span class="cov0" title="0">es.dedupCache[hash] = true
                        es.dedupKeys.PushBack(hash)
                        // LRU eviction: remove oldest entries if too large
                        for es.dedupKeys.Len() &gt; es.dedupCacheSize </span><span class="cov0" title="0">{
                                front := es.dedupKeys.Front()
                                if front != nil </span><span class="cov0" title="0">{
                                        delete(es.dedupCache, front.Value.(string))
                                        es.dedupKeys.Remove(front)
                                }</span>
                        }
                        <span class="cov0" title="0">es.dedupMutex.Unlock()</span>
                }

                <span class="cov0" title="0">batch = append(batch, event)

                if len(batch) &gt;= es.batchSize </span><span class="cov0" title="0">{
                        es.insertBatch(batch)
                        batch = batch[:0]
                }</span>
        }

        // Insert remaining
        <span class="cov0" title="0">if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                es.insertBatch(batch)
        }</span>
}

// hashEvent generates a SHA-256 hash for deduplication
func (es *EventStorage) hashEvent(event *core.Event) string <span class="cov6" title="3">{
        sourceIP := event.SourceIP
        if sourceIP == "" </span><span class="cov0" title="0">{
                sourceIP = "unknown"
        }</span>
        <span class="cov6" title="3">data := fmt.Sprintf("%s|%s|%s|%d", event.RawData, event.EventType, sourceIP, event.Timestamp.Unix())
        h := sha256.Sum256([]byte(data))
        return fmt.Sprintf("%x", h)</span>
}

// insertBatch inserts a batch of events
func (es *EventStorage) insertBatch(batch []interface{}) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), es.timeout)
        defer cancel()

        _, err := es.EventsColl.InsertMany(ctx, batch)
        if err != nil </span><span class="cov0" title="0">{
                es.logger.Errorf("Failed to insert batch: %v", err)
                // Send to dead letter
                es.insertDeadLetter(ctx, batch)
        }</span> else<span class="cov0" title="0"> {
                // Increment metrics for each event
                for _, item := range batch </span><span class="cov0" title="0">{
                        event := item.(*core.Event)
                        metrics.EventsIngested.WithLabelValues(event.SourceFormat).Inc()
                }</span>
        }
}

// insertDeadLetter inserts failed events to dead letter queue
func (es *EventStorage) insertDeadLetter(ctx context.Context, batch []interface{}) <span class="cov0" title="0">{
        dlDocs := make([]interface{}, len(batch))
        for i, doc := range batch </span><span class="cov0" title="0">{
                dlDocs[i] = bson.M{
                        "failed_at": time.Now(),
                        "document":  doc,
                }
        }</span>
        <span class="cov0" title="0">_, err := es.dlColl.InsertMany(ctx, dlDocs)
        if err != nil </span><span class="cov0" title="0">{
                es.logger.Errorf("Failed to insert to dead letter: %v", err)
                metrics.DeadLetterInsertFailures.Inc()
        }</span>
}

// Stop stops the storage workers
func (es *EventStorage) Stop() <span class="cov0" title="0">{
        es.wg.Wait()
}</span>

// CleanupOldEvents deletes events older than the specified retention period
func (es *EventStorage) CleanupOldEvents(retentionDays int) error <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        cutoff := time.Now().AddDate(0, 0, -retentionDays)
        filter := bson.M{"timestamp": bson.M{"$lt": cutoff}}

        result, err := es.EventsColl.DeleteMany(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete old events: %w", err)
        }</span>

        <span class="cov1" title="1">es.logger.Infof("Deleted %d old events", result.DeletedCount)
        return nil</span>
}

// GetEvents retrieves recent events from the database
func (es *EventStorage) GetEvents(limit int) ([]core.Event, error) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        findOptions := options.Find()
        findOptions.SetSort(bson.M{"timestamp": -1})
        findOptions.SetLimit(int64(limit))

        cursor, err := es.EventsColl.Find(ctx, bson.M{}, findOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find events: %w", err)
        }</span>
        <span class="cov1" title="1">defer cursor.Close(ctx)

        var events []core.Event
        for cursor.Next(ctx) </span><span class="cov1" title="1">{
                var event core.Event
                if err := cursor.Decode(&amp;event); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode event: %w", err)
                }</span>
                <span class="cov1" title="1">events = append(events, event)</span>
        }

        <span class="cov1" title="1">if err := cursor.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cursor error: %w", err)
        }</span>

        <span class="cov1" title="1">return events, nil</span>
}

// GetEventCount returns the total number of events
func (es *EventStorage) GetEventCount() (int64, error) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        count, err := es.EventsColl.CountDocuments(ctx, bson.M{})
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count events: %w", err)
        }</span>

        <span class="cov1" title="1">return count, nil</span>
}

// GetEventCountsByMonth returns event counts grouped by month for the last 6 months
func (es *EventStorage) GetEventCountsByMonth() ([]map[string]interface{}, error) <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Get current time and months ago
        now := time.Now()
        monthsAgo := now.AddDate(0, -defaultChartMonths, 0)

        pipeline := mongo.Pipeline{
                bson.D{{Key: "$match", Value: bson.M{"timestamp": bson.M{"$gte": monthsAgo}}}},
                bson.D{{Key: "$group", Value: bson.M{
                        "_id":   bson.M{"$dateToString": bson.M{"format": "%Y-%m", "date": "$timestamp"}},
                        "count": bson.M{"$sum": 1},
                }}},
                bson.D{{Key: "$sort", Value: bson.M{"_id": 1}}},
        }

        cursor, err := es.EventsColl.Aggregate(ctx, pipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to aggregate events: %w", err)
        }</span>
        <span class="cov1" title="1">defer cursor.Close(ctx)

        var results []bson.M
        if err = cursor.All(ctx, &amp;results); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode aggregation results: %w", err)
        }</span>

        // Map to the expected format, with month names
        <span class="cov1" title="1">chartData := make([]map[string]interface{}, 0, defaultChartMonths)

        for i := 0; i &lt; defaultChartMonths; i++ </span><span class="cov10" title="6">{
                targetMonth := now.AddDate(0, -(defaultChartMonths-1)+i, 0)
                monthStr := fmt.Sprintf("%d-%02d", targetMonth.Year(), targetMonth.Month())
                name := targetMonth.Month().String()[:3]

                count := 0
                for _, result := range results </span><span class="cov10" title="6">{
                        if id, ok := result["_id"].(string); ok &amp;&amp; id == monthStr </span><span class="cov1" title="1">{
                                if c, ok := result["count"].(int32); ok </span><span class="cov1" title="1">{
                                        count = int(c)
                                }</span>
                                <span class="cov1" title="1">break</span>
                        }
                }

                <span class="cov10" title="6">chartData = append(chartData, map[string]interface{}{
                        "name":   name,
                        "events": count,
                })</span>
        }

        <span class="cov1" title="1">return chartData, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package storage

import (
        "time"

        "go.uber.org/zap"
)

// RetentionManager handles data retention policies
type RetentionManager struct {
        eventStorage  *EventStorage
        alertStorage  *AlertStorage
        eventDays     int
        alertDays     int
        checkInterval time.Duration
        logger        *zap.SugaredLogger
        stopCh        chan struct{}
}

// NewRetentionManager creates a new retention manager
func NewRetentionManager(eventStorage *EventStorage, alertStorage *AlertStorage, eventDays, alertDays int, logger *zap.SugaredLogger) *RetentionManager <span class="cov1" title="1">{
        return &amp;RetentionManager{
                eventStorage:  eventStorage,
                alertStorage:  alertStorage,
                eventDays:     eventDays,
                alertDays:     alertDays,
                checkInterval: 24 * time.Hour, // Check daily
                logger:        logger,
                stopCh:        make(chan struct{}),
        }
}</span>

// Start starts the retention manager
func (rm *RetentionManager) Start() <span class="cov1" title="1">{
        go rm.run()
}</span>

func (rm *RetentionManager) run() <span class="cov1" title="1">{
        ticker := time.NewTicker(rm.checkInterval)
        defer ticker.Stop()

        for </span><span class="cov10" title="11">{
                select </span>{
                case &lt;-ticker.C:<span class="cov9" title="10">
                        rm.cleanup()</span>
                case &lt;-rm.stopCh:<span class="cov1" title="1">
                        return</span>
                }
        }
}

// Stop stops the retention manager
func (rm *RetentionManager) Stop() <span class="cov1" title="1">{
        close(rm.stopCh)
}</span>

// cleanup performs retention cleanup
func (rm *RetentionManager) cleanup() <span class="cov10" title="11">{
        rm.logger.Info("Starting data retention cleanup")

        if rm.eventStorage != nil </span><span class="cov0" title="0">{
                if err := rm.eventStorage.CleanupOldEvents(rm.eventDays); err != nil </span><span class="cov0" title="0">{
                        rm.logger.Errorf("Failed to cleanup old events: %v", err)
                }</span>
        }

        <span class="cov10" title="11">if rm.alertStorage != nil </span><span class="cov0" title="0">{
                if err := rm.alertStorage.CleanupOldAlerts(rm.alertDays); err != nil </span><span class="cov0" title="0">{
                        rm.logger.Errorf("Failed to cleanup old alerts: %v", err)
                }</span>
        }

        <span class="cov10" title="11">rm.logger.Info("Data retention cleanup completed")</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package storage

import (
        "context"
        "errors"
        "fmt"
        "time"

        "cerberus/core"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var ErrRuleNotFound = errors.New("rule not found")

// RuleCursor interface for mocking
type RuleCursor interface {
        All(ctx context.Context, results interface{}) error
        Close(ctx context.Context) error
        Err() error
}

// RuleSingleResult interface for mocking
type RuleSingleResult interface {
        Decode(v interface{}) error
}

// RuleCollection interface for mocking
type RuleCollection interface {
        Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (RuleCursor, error)
        FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) RuleSingleResult
        InsertOne(ctx context.Context, document interface{}, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error)
        UpdateOne(ctx context.Context, filter interface{}, update interface{}, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error)
        DeleteOne(ctx context.Context, filter interface{}, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error)
}

// mongoRuleCursor adapts *mongo.Cursor to RuleCursor
type mongoRuleCursor struct {
        *mongo.Cursor
}

func (m *mongoRuleCursor) All(ctx context.Context, results interface{}) error <span class="cov0" title="0">{
        return m.Cursor.All(ctx, results)
}</span>

func (m *mongoRuleCursor) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.Cursor.Close(ctx)
}</span>

func (m *mongoRuleCursor) Err() error <span class="cov0" title="0">{
        return m.Cursor.Err()
}</span>

// mongoRuleSingleResult adapts *mongo.SingleResult to RuleSingleResult
type mongoRuleSingleResult struct {
        *mongo.SingleResult
}

func (m *mongoRuleSingleResult) Decode(v interface{}) error <span class="cov0" title="0">{
        return m.SingleResult.Decode(v)
}</span>

// mongoRuleCollection adapts *mongo.Collection to RuleCollection
type mongoRuleCollection struct {
        *mongo.Collection
}

func (m *mongoRuleCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (RuleCursor, error) <span class="cov0" title="0">{
        cursor, err := m.Collection.Find(ctx, filter, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mongoRuleCursor{Cursor: cursor}, nil</span>
}

func (m *mongoRuleCollection) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) RuleSingleResult <span class="cov0" title="0">{
        return &amp;mongoRuleSingleResult{SingleResult: m.Collection.FindOne(ctx, filter, opts...)}
}</span>

// RuleStorage handles rule persistence and retrieval
type RuleStorage struct {
        mongoDB   *MongoDB
        rulesColl RuleCollection
}

// NewRuleStorage creates a new rule storage handler
func NewRuleStorage(mongoDB *MongoDB) *RuleStorage <span class="cov0" title="0">{
        return &amp;RuleStorage{
                mongoDB:   mongoDB,
                rulesColl: &amp;mongoRuleCollection{Collection: mongoDB.Database.Collection("rules")},
        }
}</span>

// GetRules retrieves all rules from the database
func (rs *RuleStorage) GetRules() ([]core.Rule, error) <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        cursor, err := rs.rulesColl.Find(ctx, bson.M{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to find rules: %w", err)
        }</span>
        <span class="cov1" title="1">defer cursor.Close(ctx)

        var rules []core.Rule
        if err = cursor.All(ctx, &amp;rules); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode rules: %w", err)
        }</span>

        <span class="cov1" title="1">return rules, nil</span>
}

// GetRule retrieves a single rule by ID
func (rs *RuleStorage) GetRule(id string) (*core.Rule, error) <span class="cov10" title="6">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        var rule core.Rule
        err := rs.rulesColl.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;rule)
        if err != nil </span><span class="cov6" title="3">{
                if err == mongo.ErrNoDocuments </span><span class="cov6" title="3">{
                        return nil, ErrRuleNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to find rule: %w", err)</span>
        }

        <span class="cov6" title="3">return &amp;rule, nil</span>
}

// CreateRule inserts a new rule
func (rs *RuleStorage) CreateRule(rule *core.Rule) error <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Check if rule with same ID exists
        existing, err := rs.GetRule(rule.ID)
        if err != nil &amp;&amp; err != ErrRuleNotFound </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check existing rule: %w", err)
        }</span>
        <span class="cov4" title="2">if existing != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("rule with ID %s already exists", rule.ID)
        }</span>

        <span class="cov1" title="1">_, err = rs.rulesColl.InsertOne(ctx, rule)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert rule: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// UpdateRule updates an existing rule
func (rs *RuleStorage) UpdateRule(id string, rule *core.Rule) error <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Get current rule to increment version
        current, err := rs.GetRule(id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">rule.Version = current.Version + 1

        filter := bson.M{"_id": id}
        update := bson.M{"$set": rule}

        result, err := rs.rulesColl.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update rule: %w", err)
        }</span>

        <span class="cov1" title="1">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return ErrRuleNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DeleteRule deletes a rule by ID
func (rs *RuleStorage) DeleteRule(id string) error <span class="cov4" title="2">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        result, err := rs.rulesColl.DeleteOne(ctx, bson.M{"_id": id})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete rule: %w", err)
        }</span>

        <span class="cov4" title="2">if result.DeletedCount == 0 </span><span class="cov1" title="1">{
                return ErrRuleNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// EnsureIndexes creates necessary indexes for rules collection
func (rs *RuleStorage) EnsureIndexes() error <span class="cov1" title="1">{
        // _id is automatically indexed, no need for additional index
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
