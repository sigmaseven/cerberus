package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"cerberus/core"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestRuleLifecycle_Complete tests the complete lifecycle of a rule
// PRODUCTION: Tests create -> read -> update -> delete flow
func TestRuleLifecycle_Complete(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Step 1: Create rule
	// NOTE: ID is auto-generated by the handler, so we don't provide it
	// TASK #184: Use sigma_yaml instead of legacy conditions
	rule := map[string]interface{}{
		"type":        "sigma",
		"name":        "Lifecycle Test Rule",
		"description": "Testing complete lifecycle",
		"severity":    "High",
		"version":     1,
		"enabled":     true,
		"sigma_yaml": `title: Lifecycle Test Rule
logsource:
  category: test
detection:
  selection:
    event_type: login
  condition: selection
`,
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusCreated, w.Code, "Should create rule successfully")

	// Extract the generated rule ID from the response
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	ruleID, ok := createdRule["id"].(string)
	require.True(t, ok, "Should have ID in response")
	require.NotEmpty(t, ruleID, "ID should not be empty")

	// Step 2: Read rule
	req = httptest.NewRequest("GET", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code, "Should retrieve rule successfully")

	// GET returns wrapped response {"category": "detection", "rule": {...}}
	var getResponse map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &getResponse)
	retrievedRule := getResponse["rule"].(map[string]interface{})
	assert.Equal(t, "Lifecycle Test Rule", retrievedRule["name"])

	// Step 3: Update rule
	// TASK #184: Include sigma_yaml for updated rule
	update := map[string]interface{}{
		"type":     "sigma",
		"name":     "Updated Lifecycle Rule",
		"severity": "Critical",
		"enabled":  false,
		"version":  1, // Required: version must be positive
		"sigma_yaml": `title: Updated Lifecycle Rule
logsource:
  category: test
detection:
  selection:
    event_type: login
  condition: selection
`,
	}

	body, _ = json.Marshal(update)
	req = httptest.NewRequest("PUT", "/api/v1/rules/"+ruleID, bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code, "Should update rule successfully")

	// Step 4: Verify update
	req = httptest.NewRequest("GET", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	// GET returns wrapped response {"category": "detection", "rule": {...}}
	json.Unmarshal(w.Body.Bytes(), &getResponse)
	updatedRule := getResponse["rule"].(map[string]interface{})
	assert.Equal(t, "Updated Lifecycle Rule", updatedRule["name"])
	assert.Equal(t, "Critical", updatedRule["severity"])
	assert.Equal(t, false, updatedRule["enabled"])

	// Step 5: Delete rule
	req = httptest.NewRequest("DELETE", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.True(t, w.Code == http.StatusOK || w.Code == http.StatusNoContent, "Should delete rule successfully")

	// Step 6: Verify deletion
	req = httptest.NewRequest("GET", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNotFound, w.Code, "Rule should not exist after deletion")
}

// TestGetRule_AllFields tests retrieving a rule with all fields populated
func TestGetRule_AllFields(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Create a rule with all fields
	// NOTE: ID is auto-generated by the handler
	// TASK #184: Use sigma_yaml instead of legacy conditions
	rule := map[string]interface{}{
		"type":        "sigma",
		"name":        "Full Rule",
		"description": "Rule with all fields",
		"severity":    "Medium",
		"version":     1, // Required: version must be positive
		"enabled":     true,
		"sigma_yaml": `title: Full Rule
logsource:
  category: authentication
detection:
  selection:
    event_type: login
    username|contains: admin
  condition: selection
`,
		"tags":             []string{"authentication", "login"},
		"mitre_tactics":    []string{"TA0001"},
		"mitre_techniques": []string{"T1078"},
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	require.Equal(t, http.StatusCreated, w.Code)

	// Extract created rule ID from response
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	ruleID, ok := createdRule["id"].(string)
	require.True(t, ok, "Should have ID in response")

	// Retrieve the rule by its ID
	req = httptest.NewRequest("GET", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	// Unified API returns {"category": "detection", "rule": {...}}
	var response struct {
		Category string    `json:"category"`
		Rule     core.Rule `json:"rule"`
	}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "Full Rule", response.Rule.Name)
	assert.Equal(t, "Medium", response.Rule.Severity)
	// TASK #184: Check sigma_yaml instead of conditions
	assert.NotEmpty(t, response.Rule.SigmaYAML)
}

// TestGetRules_PaginationExtended tests listing rules with pagination (extended test)
func TestGetRules_PaginationExtended(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Create multiple rules
	// TASK #184: Use sigma_yaml instead of legacy conditions
	for i := 1; i <= 15; i++ {
		rule := map[string]interface{}{
			"type":        "sigma",
			"name":        fmt.Sprintf("Pagination Rule %d", i),
			"description": "Testing pagination",
			"severity":    "Low",
			"version":     1, // Required: version must be positive
			"enabled":     true,
			"sigma_yaml": fmt.Sprintf(`title: Pagination Rule %d
logsource:
  category: test
detection:
  selection:
    event_type: test
  condition: selection
`, i),
		}

		body, _ := json.Marshal(rule)
		req := httptest.NewRequest("POST", "/api/v1/rules", bytes.NewReader(body))
		req.Header.Set("Authorization", "Bearer "+token)
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("X-CSRF-Token", csrfToken)
		addCSRFToRequest(t, req)

		w := httptest.NewRecorder()
		testAPI.router.ServeHTTP(w, req)
		require.Equal(t, http.StatusCreated, w.Code, "Failed to create rule %d", i)
	}

	// Test pagination - page 1
	req := httptest.NewRequest("GET", "/api/v1/rules?limit=10&offset=0", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err, "Response should be valid JSON")
	// Unified rules endpoint returns "items" key, not "rules"
	items, ok := response["items"].([]interface{})
	require.True(t, ok, "Response should have 'items' array, got: %v", response)
	assert.LessOrEqual(t, len(items), 10, "Should return at most 10 rules")

	// Test pagination - page 2
	req = httptest.NewRequest("GET", "/api/v1/rules?limit=10&offset=10", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

// TestUpdateRule_PartialUpdateExtended tests updating only some fields of a rule (extended test)
func TestUpdateRule_PartialUpdateExtended(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Create initial rule with sigma_yaml (required for SIGMA rules)
	rule := map[string]interface{}{
		"type":        "sigma",
		"name":        "Original Name",
		"description": "Original Description",
		"severity":    "Low",
		"version":     1,
		"enabled":     true,
		"sigma_yaml": `title: Original Rule
logsource:
  category: test
detection:
  selection:
    EventID: 1
  condition: selection
`,
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	require.Equal(t, http.StatusCreated, w.Code, "Response: %s", w.Body.String())

	// Extract generated rule ID from response
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	ruleID, ok := createdRule["id"].(string)
	require.True(t, ok, "Should have ID in response")

	// Update only name and severity (must include sigma_yaml for SIGMA rules)
	update := map[string]interface{}{
		"type":     "sigma",
		"name":     "Updated Name",
		"severity": "Critical",
		"version":  1,
		"sigma_yaml": `title: Updated Rule
logsource:
  category: test
detection:
  selection:
    EventID: 1
  condition: selection
`,
	}

	body, _ = json.Marshal(update)
	req = httptest.NewRequest("PUT", "/api/v1/rules/"+ruleID, bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code, "Response: %s", w.Body.String())

	// Verify the update - unified API returns {"category": "detection", "rule": {...}}
	req = httptest.NewRequest("GET", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	var response struct {
		Category string    `json:"category"`
		Rule     core.Rule `json:"rule"`
	}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "Updated Name", response.Rule.Name)
	assert.Equal(t, "Critical", response.Rule.Severity)
}

// TestUpdateRule_NonExistent tests updating a rule that doesn't exist
func TestUpdateRule_NonExistent(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	update := map[string]interface{}{
		"name":    "Updated Name",
		"version": 1, // Required: version must be positive
	}

	body, _ := json.Marshal(update)
	req := httptest.NewRequest("PUT", "/api/v1/rules/nonexistent-rule", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNotFound, w.Code, "Should return 404 for non-existent rule")
}

// TestDeleteRule_Success tests successful rule deletion
func TestDeleteRule_Success(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Create rule with sigma_yaml (required for SIGMA rules)
	rule := map[string]interface{}{
		"type":     "sigma",
		"name":     "Delete Test",
		"severity": "Low",
		"version":  1,
		"enabled":  true,
		"sigma_yaml": `title: Delete Test Rule
logsource:
  category: test
detection:
  selection:
    EventID: 1
  condition: selection
`,
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	require.Equal(t, http.StatusCreated, w.Code, "Response: %s", w.Body.String())

	// Extract generated rule ID from response
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	ruleID, ok := createdRule["id"].(string)
	require.True(t, ok, "Should have ID in response")

	// Delete rule
	req = httptest.NewRequest("DELETE", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.True(t, w.Code == http.StatusOK || w.Code == http.StatusNoContent, "Should delete successfully")

	// Verify deletion
	req = httptest.NewRequest("GET", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNotFound, w.Code, "Rule should not exist")
}

// TestDeleteRule_NonExistent tests deleting a rule that doesn't exist
func TestDeleteRule_NonExistent(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	req := httptest.NewRequest("DELETE", "/api/v1/rules/nonexistent-rule", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNotFound, w.Code, "Should return 404 for non-existent rule")
}

// TestCreateRule_ComplexConditions tests creating a rule with complex SIGMA detection
// TASK #184: Updated to use sigma_yaml instead of legacy conditions
func TestCreateRule_ComplexConditions(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Complex SIGMA rule with multiple detection conditions
	sigmaYAML := `title: Complex Detection Test
logsource:
  category: authentication
  product: windows
detection:
  selection:
    event_type: authentication
  filter_system:
    username: system
  selection_ip:
    source_ip|startswith: '192.168.'
  condition: selection and not filter_system and selection_ip
`

	rule := map[string]interface{}{
		"type":        "sigma",
		"name":        "Complex Conditions Test",
		"description": "Testing complex rule conditions",
		"severity":    "High",
		"version":     1,
		"enabled":     true,
		"sigma_yaml":  sigmaYAML,
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusCreated, w.Code, "Should create rule with complex SIGMA detection")

	// Extract generated rule ID from response
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	ruleID, ok := createdRule["id"].(string)
	require.True(t, ok, "Should have ID in response")

	// Verify the rule was created correctly
	req = httptest.NewRequest("GET", "/api/v1/rules/"+ruleID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	// Unified API returns {"category": "detection", "rule": {...}}
	var response struct {
		Category string    `json:"category"`
		Rule     core.Rule `json:"rule"`
	}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.NotEmpty(t, response.Rule.SigmaYAML, "Should have SigmaYAML")
}

// TestCreateRule_ValidationErrors tests various validation error scenarios
func TestCreateRule_ValidationErrors(t *testing.T) {
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	testCases := []struct {
		name           string
		rule           map[string]interface{}
		expectedStatus int
	}{
		{
			name: "Missing ID",
			rule: map[string]interface{}{
				"name":     "Test Rule",
				"severity": "High",
			},
			expectedStatus: http.StatusBadRequest,
		},
		{
			name: "Missing Name",
			rule: map[string]interface{}{
				"id":       "test-rule-missing-name",
				"severity": "High",
			},
			expectedStatus: http.StatusBadRequest,
		},
		{
			name: "Invalid Severity",
			rule: map[string]interface{}{
				"id":       "test-rule-invalid-severity",
				"name":     "Test Rule",
				"severity": "super-duper-critical",
			},
			expectedStatus: http.StatusBadRequest,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			body, _ := json.Marshal(tc.rule)
			req := httptest.NewRequest("POST", "/api/v1/rules", bytes.NewReader(body))
			req.Header.Set("Authorization", "Bearer "+token)
			req.Header.Set("Content-Type", "application/json")
			req.Header.Set("X-CSRF-Token", csrfToken)
			addCSRFToRequest(t, req)

			w := httptest.NewRecorder()
			testAPI.router.ServeHTTP(w, req)
			assert.Equal(t, tc.expectedStatus, w.Code, "Test case: "+tc.name)
		})
	}
}
