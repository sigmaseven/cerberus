package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestCorrelationRuleLifecycle_Complete tests the complete lifecycle of a correlation rule
// PRODUCTION: Tests create -> read -> update -> delete flow
// TASK #173: Skipped - /api/v1/correlation-rules endpoint deprecated, returns 410 Gone
func TestCorrelationRuleLifecycle_Complete(t *testing.T) {
	t.Skip("TASK #173: /api/v1/correlation-rules endpoint deprecated - use /api/v1/rules?category=correlation")
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Step 1: Create correlation rule
	// NOTE: ID is auto-generated by the handler, so we don't provide it
	rule := map[string]interface{}{
		"name":        "Correlation Lifecycle Test",
		"description": "Testing complete correlation lifecycle",
		"severity":    "High",
		"version":     1,
		"window":      300000000000, // 5 minutes in nanoseconds
		"conditions": []map[string]interface{}{
			{
				"field":    "event_type",
				"operator": "equals",
				"value":    "login_failed",
				"logic":    "AND",
			},
		},
		"sequence": []string{"login_failed", "login_failed", "login_failed"},
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/correlation-rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusCreated, w.Code, "Should create correlation rule successfully")

	// Extract the generated correlation rule ID from the response
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	corrID, ok := createdRule["id"].(string)
	require.True(t, ok, "Should have ID in response")
	require.NotEmpty(t, corrID, "ID should not be empty")

	// Step 2: Read correlation rule
	req = httptest.NewRequest("GET", "/api/v1/correlation-rules/"+corrID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code, "Should retrieve correlation rule successfully")

	var retrievedRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &retrievedRule)
	assert.Equal(t, "Correlation Lifecycle Test", retrievedRule["name"])

	// Step 3: Update correlation rule
	update := map[string]interface{}{
		"name":     "Updated Correlation Rule",
		"severity": "Critical",
		"version":  1,
		"window":   600000000000,
		"conditions": []map[string]interface{}{
			{
				"field":    "event_type",
				"operator": "equals",
				"value":    "login_failed",
				"logic":    "AND",
			},
		},
		"sequence": []string{"login_failed", "login_failed", "login_failed"},
	}

	body, _ = json.Marshal(update)
	req = httptest.NewRequest("PUT", "/api/v1/correlation-rules/"+corrID, bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code, "Should update correlation rule successfully")

	// Step 4: Verify update
	req = httptest.NewRequest("GET", "/api/v1/correlation-rules/"+corrID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	json.Unmarshal(w.Body.Bytes(), &retrievedRule)
	assert.Equal(t, "Updated Correlation Rule", retrievedRule["name"])
	// Note: Some storage backends store severity as lowercase
	severityStr := retrievedRule["severity"].(string)
	assert.True(t, severityStr == "Critical" || severityStr == "critical")

	// Step 5: Delete correlation rule
	req = httptest.NewRequest("DELETE", "/api/v1/correlation-rules/"+corrID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.True(t, w.Code == http.StatusOK || w.Code == http.StatusNoContent, "Should delete correlation rule successfully")

	// Step 6: Verify deletion
	req = httptest.NewRequest("GET", "/api/v1/correlation-rules/"+corrID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNotFound, w.Code, "Correlation rule should not exist after deletion")
}

// TestGetCorrelationRule_AllFields tests retrieving a correlation rule with all fields
// TASK #173: Skipped - /api/v1/correlation-rules endpoint deprecated
func TestGetCorrelationRule_AllFields(t *testing.T) {
	t.Skip("TASK #173: /api/v1/correlation-rules endpoint deprecated - use /api/v1/rules?category=correlation")
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Create a correlation rule with all fields
	// NOTE: ID is auto-generated
	rule := map[string]interface{}{
		"name":        "Full Correlation Rule",
		"description": "Correlation rule with all fields",
		"severity":    "Medium",
		"version":     1,
		"window":      300000000000,
		"conditions": []map[string]interface{}{
			{
				"field":    "event_type",
				"operator": "equals",
				"value":    "login_failed",
				"logic":    "AND",
			},
			{
				"field":    "username",
				"operator": "equals",
				"value":    "admin",
				"logic":    "AND",
			},
		},
		"sequence":         []string{"login_failed", "account_locked"},
		"actions":          []map[string]interface{}{{"id": "action-1"}, {"id": "action-2"}},
		"tags":             []string{"authentication", "brute-force"},
		"mitre_tactics":    []string{"TA0006"},
		"mitre_techniques": []string{"T1110"},
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/correlation-rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	require.Equal(t, http.StatusCreated, w.Code)

	// Extract ID from response
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	corrID := createdRule["id"].(string)

	// Retrieve the correlation rule
	req = httptest.NewRequest("GET", "/api/v1/correlation-rules/"+corrID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var retrievedRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &retrievedRule)
	assert.Equal(t, "Full Correlation Rule", retrievedRule["name"])
	assert.NotNil(t, retrievedRule["conditions"])
}

// TestGetCorrelationRules_PaginationExtended tests listing correlation rules with pagination (extended test)
// TASK #173: Skipped - /api/v1/correlation-rules endpoint deprecated
func TestGetCorrelationRules_PaginationExtended(t *testing.T) {
	t.Skip("TASK #173: /api/v1/correlation-rules endpoint deprecated - use /api/v1/rules?category=correlation")
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Create multiple correlation rules
	for i := 1; i <= 12; i++ {
		rule := map[string]interface{}{
			"name":        fmt.Sprintf("Pagination Correlation Rule %d", i),
			"description": "Testing pagination",
			"severity":    "Low",
			"version":     1,
			"window":      300000000000,
			"conditions": []map[string]interface{}{
				{
					"field":    "event_type",
					"operator": "equals",
					"value":    "test_event",
					"logic":    "AND",
				},
			},
			"sequence": []string{"test_event", "test_event"},
		}

		body, _ := json.Marshal(rule)
		req := httptest.NewRequest("POST", "/api/v1/correlation-rules", bytes.NewReader(body))
		req.Header.Set("Authorization", "Bearer "+token)
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("X-CSRF-Token", csrfToken)
		addCSRFToRequest(t, req)

		w := httptest.NewRecorder()
		testAPI.router.ServeHTTP(w, req)
		require.Equal(t, http.StatusCreated, w.Code, "Failed to create correlation rule %d", i)
	}

	// Test pagination - page 1
	req := httptest.NewRequest("GET", "/api/v1/correlation-rules?limit=10&offset=0", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	// REQUIREMENT: API returns correlation rules as an array (not wrapped in a map)
	var rules []interface{}
	err := json.Unmarshal(w.Body.Bytes(), &rules)
	require.NoError(t, err, "Should parse response JSON as array")
	require.NotNil(t, rules, "Rules array should not be nil")
	assert.LessOrEqual(t, len(rules), 10, "Should return at most 10 correlation rules")

	// Test pagination - page 2
	req = httptest.NewRequest("GET", "/api/v1/correlation-rules?limit=10&offset=10", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

// TestUpdateCorrelationRule_PartialUpdateExtended tests updating only some fields (extended test)
// TASK #173: Skipped - /api/v1/correlation-rules endpoint deprecated
func TestUpdateCorrelationRule_PartialUpdateExtended(t *testing.T) {
	t.Skip("TASK #173: /api/v1/correlation-rules endpoint deprecated - use /api/v1/rules?category=correlation")
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Create initial correlation rule
	rule := map[string]interface{}{
		"name":        "Original Name",
		"description": "Original Description",
		"severity":    "Low",
		"version":     1,
		"window":      300000000000,
		"conditions": []map[string]interface{}{
			{
				"field":    "event_type",
				"operator": "equals",
				"value":    "test_event",
				"logic":    "AND",
			},
		},
		"sequence": []string{"test_event", "test_event"},
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/correlation-rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	require.Equal(t, http.StatusCreated, w.Code)

	// Extract ID
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	corrID := createdRule["id"].(string)

	// Update only name and window
	update := map[string]interface{}{
		"name":    "Updated Name",
		"version": 1,
		"window":  600000000000,
		"conditions": []map[string]interface{}{
			{
				"field":    "event_type",
				"operator": "equals",
				"value":    "test_event",
				"logic":    "AND",
			},
		},
		"sequence": []string{"test_event", "test_event"},
	}

	body, _ = json.Marshal(update)
	req = httptest.NewRequest("PUT", "/api/v1/correlation-rules/"+corrID, bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code)

	// Verify the update
	req = httptest.NewRequest("GET", "/api/v1/correlation-rules/"+corrID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)

	var retrievedRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &retrievedRule)
	assert.Equal(t, "Updated Name", retrievedRule["name"])
	// Description should remain unchanged
	assert.Equal(t, "Original Description", retrievedRule["description"])
}

// TestUpdateCorrelationRule_NonExistent tests updating a rule that doesn't exist
// TASK #173: Skipped - /api/v1/correlation-rules endpoint deprecated
func TestUpdateCorrelationRule_NonExistent(t *testing.T) {
	t.Skip("TASK #173: /api/v1/correlation-rules endpoint deprecated - use /api/v1/rules?category=correlation")
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	update := map[string]interface{}{
		"name": "Updated Name",
	}

	body, _ := json.Marshal(update)
	req := httptest.NewRequest("PUT", "/api/v1/correlation-rules/nonexistent-corr-rule", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNotFound, w.Code, "Should return 404 for non-existent correlation rule")
}

// TestDeleteCorrelationRule_Success tests successful correlation rule deletion
// TASK #173: Skipped - /api/v1/correlation-rules endpoint deprecated
func TestDeleteCorrelationRule_Success(t *testing.T) {
	t.Skip("TASK #173: /api/v1/correlation-rules endpoint deprecated - use /api/v1/rules?category=correlation")
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	// Create correlation rule
	rule := map[string]interface{}{
		"name":     "Delete Test",
		"severity": "Low",
		"version":  1,
		"window":   300000000000,
		"conditions": []map[string]interface{}{
			{
				"field":    "event_type",
				"operator": "equals",
				"value":    "test_event",
				"logic":    "AND",
			},
		},
		"sequence": []string{"test_event", "test_event"},
	}

	body, _ := json.Marshal(rule)
	req := httptest.NewRequest("POST", "/api/v1/correlation-rules", bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	require.Equal(t, http.StatusCreated, w.Code)

	// Extract ID
	var createdRule map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &createdRule)
	corrID := createdRule["id"].(string)

	// Delete correlation rule
	req = httptest.NewRequest("DELETE", "/api/v1/correlation-rules/"+corrID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.True(t, w.Code == http.StatusOK || w.Code == http.StatusNoContent, "Should delete successfully")

	// Verify deletion
	req = httptest.NewRequest("GET", "/api/v1/correlation-rules/"+corrID, nil)
	req.Header.Set("Authorization", "Bearer "+token)
	w = httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNotFound, w.Code, "Correlation rule should not exist")
}

// TestDeleteCorrelationRule_NonExistent tests deleting a correlation rule that doesn't exist
// TASK #173: Skipped - /api/v1/correlation-rules endpoint deprecated
func TestDeleteCorrelationRule_NonExistent(t *testing.T) {
	t.Skip("TASK #173: /api/v1/correlation-rules endpoint deprecated - use /api/v1/rules?category=correlation")
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	req := httptest.NewRequest("DELETE", "/api/v1/correlation-rules/nonexistent-corr-rule", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("X-CSRF-Token", csrfToken)
	addCSRFToRequest(t, req)

	w := httptest.NewRecorder()
	testAPI.router.ServeHTTP(w, req)
	assert.Equal(t, http.StatusNotFound, w.Code, "Should return 404 for non-existent correlation rule")
}

// TestCreateCorrelationRule_SigmaFormat tests creating a correlation rule using SIGMA YAML format
// TASK #184: Updated to use unified /api/v1/rules endpoint with SIGMA YAML correlation syntax
// NOTE: Correlation rule creation via unified endpoint is not yet implemented (returns 501)
func TestCreateCorrelationRule_SigmaFormat(t *testing.T) {
	// Skip: Correlation rule creation via unified endpoint is not yet implemented
	// The deprecated /api/v1/correlation-rules endpoint returns 410 Gone
	// The new /api/v1/rules endpoint returns 501 Not Implemented for correlation type
	// This test should be enabled once unified correlation creation is implemented
	t.Skip("TASK #173: Correlation rule creation via unified /api/v1/rules endpoint not yet implemented")
}

// TestCreateCorrelationRule_ValidationErrors tests various validation error scenarios
// TASK #173: Skipped - /api/v1/correlation-rules endpoint deprecated
func TestCreateCorrelationRule_ValidationErrors(t *testing.T) {
	t.Skip("TASK #173: /api/v1/correlation-rules endpoint deprecated - use /api/v1/rules?category=correlation")
	testAPI, cleanup := setupTestAPI(t)
	defer cleanup()

	token := createValidTestToken(t, testAPI.config.Auth.JWTSecret, "admin")
	csrfToken := generateValidCSRFToken(t)

	testCases := []struct {
		name           string
		rule           map[string]interface{}
		expectedStatus int
	}{
		{
			name: "Missing Name",
			rule: map[string]interface{}{
				"severity": "High",
				"window":   300000000000,
			},
			expectedStatus: http.StatusBadRequest,
		},
		{
			name: "Invalid Severity",
			rule: map[string]interface{}{
				"name":     "Test Correlation Rule",
				"severity": "ultra-mega-critical",
				"window":   300000000000,
			},
			expectedStatus: http.StatusBadRequest,
		},
		{
			name: "Missing Window",
			rule: map[string]interface{}{
				"name":     "Test Correlation Rule",
				"severity": "High",
			},
			expectedStatus: http.StatusBadRequest,
		},
		{
			name: "Zero Window",
			rule: map[string]interface{}{
				"name":     "Test Correlation Rule",
				"severity": "High",
				"window":   0,
			},
			expectedStatus: http.StatusBadRequest,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			body, _ := json.Marshal(tc.rule)
			req := httptest.NewRequest("POST", "/api/v1/correlation-rules", bytes.NewReader(body))
			req.Header.Set("Authorization", "Bearer "+token)
			req.Header.Set("Content-Type", "application/json")
			req.Header.Set("X-CSRF-Token", csrfToken)
			addCSRFToRequest(t, req)

			w := httptest.NewRecorder()
			testAPI.router.ServeHTTP(w, req)
			assert.Equal(t, tc.expectedStatus, w.Code, "Test case: "+tc.name)
		})
	}
}
