package core

import (
	"errors"
	"strings"
	"time"

	"github.com/google/uuid"
)

// RuleType constants for distinguishing alert sources
const (
	RuleTypeSigma       = "sigma"       // Standard SIGMA detection rule
	RuleTypeCorrelation = "correlation" // Correlation rule (sequence/chain detection)
	RuleTypeCQL         = "cql"         // CQL-based rule
	RuleTypeML          = "ml"          // Machine learning anomaly detection
)

// Alert represents a security alert generated by rule matches
// TASK 109: Alert response serialization - All fields are JSON-serialized with these naming conventions:
//   - disposition: AlertDisposition enum ("undetermined", "true_positive", "false_positive", "benign")
//   - disposition_reason: Optional reason text (omitted if empty)
//   - disposition_set_at: ISO8601 timestamp when disposition was set (omitted if nil)
//   - disposition_set_by: Username who set disposition (omitted if empty)
//   - investigation_id: UUID of linked investigation (omitted if empty)
//   - assigned_to: Username of assignee (omitted if empty)
//
// Correlation alert fields:
//   - rule_type: Distinguishes alert source ("sigma", "correlation", "cql", "ml")
//   - correlated_alert_ids: For correlation alerts, IDs of contributing alerts
//   - correlation_rule_id: For contributing alerts, which correlation rule they fed into
//
// Overview metadata fields (for alert info modal):
//   - category: Alert classification (malware, phishing, intrusion, data_exfiltration, etc.)
//   - source: System that generated the alert (derived from rule logsource or listener)
//   - confidence_score: Detection confidence 0-100 (how confident the rule is)
//   - risk_score: Calculated risk 0-100 (based on asset criticality, severity, etc.)
//   - occurrence_count: Total occurrences of this alert pattern
//   - sla_breached: Whether response SLA was violated
//
// Frontend can compute hasDisposition as: disposition !== "undetermined"
type Alert struct {
	AlertID         string                 `json:"alert_id" bson:"alert_id" example:"alert-123"`
	RuleID          string                 `json:"rule_id" bson:"rule_id" example:"failed_login"`
	EventID         string                 `json:"event_id" bson:"event_id" example:"event-456"`
	Timestamp       time.Time              `json:"timestamp" bson:"timestamp" swaggertype:"string" example:"2023-10-31T12:00:00Z"`
	Severity        string                 `json:"severity" bson:"severity" example:"Warning"`
	Status          AlertStatus            `json:"status" bson:"status" example:"Pending"` // Pending, Acknowledged, Dismissed
	JiraTicketID    string                 `json:"jira_ticket_id,omitempty" bson:"jira_ticket_id,omitempty" example:"PROJ-123"`
	Event           *Event                 `json:"event" bson:"event"`
	RuleName        string                 `json:"rule_name,omitempty" bson:"rule_name,omitempty"`
	RuleDescription string                 `json:"rule_description,omitempty" bson:"rule_description,omitempty"`
	RuleType        string                 `json:"rule_type,omitempty" bson:"rule_type,omitempty"` // sigma, correlation, cql, ml
	MitreTechniques []string               `json:"mitre_techniques,omitempty" bson:"mitre_techniques,omitempty"`
	Fingerprint     string                 `json:"fingerprint,omitempty" bson:"fingerprint,omitempty"`
	DuplicateCount  int                    `json:"duplicate_count,omitempty" bson:"duplicate_count,omitempty"`
	LastSeen        time.Time              `json:"last_seen,omitempty" bson:"last_seen,omitempty" swaggertype:"string"`
	EventIDs        []string               `json:"event_ids,omitempty" bson:"event_ids,omitempty"`
	ThreatIntel     map[string]interface{} `json:"threat_intel,omitempty" bson:"threat_intel,omitempty"`
	AssignedTo      string                 `json:"assigned_to,omitempty" bson:"assigned_to,omitempty"`

	// Correlation tracking fields
	// For correlation alerts: IDs of the contributing alerts that triggered this correlation
	CorrelatedAlertIDs []string `json:"correlated_alert_ids,omitempty" bson:"correlated_alert_ids,omitempty"`
	// For contributing alerts: which correlation rule(s) this alert contributed to
	CorrelationRuleID string `json:"correlation_rule_id,omitempty" bson:"correlation_rule_id,omitempty"`

	// TASK 102: Disposition workflow fields for analyst verdict
	Disposition       AlertDisposition `json:"disposition" bson:"disposition" example:"undetermined"`
	DispositionReason string           `json:"disposition_reason,omitempty" bson:"disposition_reason,omitempty" example:"Confirmed malicious activity"`
	DispositionSetAt  *time.Time       `json:"disposition_set_at,omitempty" bson:"disposition_set_at,omitempty" swaggertype:"string"`
	DispositionSetBy  string           `json:"disposition_set_by,omitempty" bson:"disposition_set_by,omitempty" example:"analyst@company.com"`
	InvestigationID   string           `json:"investigation_id,omitempty" bson:"investigation_id,omitempty" example:"inv-789"`

	// Alert Info Modal - Overview metadata fields
	// Category represents the alert classification (e.g., malware, phishing, intrusion, data_exfiltration)
	Category string `json:"category,omitempty" bson:"category,omitempty" example:"intrusion"`
	// Source identifies the system that generated the alert (e.g., Windows Security, Splunk, Sysmon)
	Source string `json:"source,omitempty" bson:"source,omitempty" example:"Windows Security"`
	// ConfidenceScore indicates detection confidence as percentage (0-100)
	ConfidenceScore float64 `json:"confidence_score,omitempty" bson:"confidence_score,omitempty" example:"85.5"`
	// RiskScore is the calculated risk level (0-100) based on asset criticality, severity, threat intel
	RiskScore int `json:"risk_score,omitempty" bson:"risk_score,omitempty" example:"75"`
	// OccurrenceCount tracks how many times this alert pattern has triggered (for aggregated alerts)
	OccurrenceCount int `json:"occurrence_count,omitempty" bson:"occurrence_count,omitempty" example:"3"`
	// SLABreached indicates whether the response SLA was violated
	SLABreached bool `json:"sla_breached,omitempty" bson:"sla_breached,omitempty" example:"false"`
}

// ErrNilEvent is returned when attempting to create an alert with a nil event
var ErrNilEvent = errors.New("event cannot be nil: violates ALERT-001 requirement (docs/requirements/alert-requirements.md)")

// StatusChange represents a single status change in an alert's history
// Used for timeline display in the alert investigation modal
type StatusChange struct {
	AlertID    string      `json:"alert_id" bson:"alert_id"`
	FromStatus AlertStatus `json:"from_status" bson:"from_status"`
	ToStatus   AlertStatus `json:"to_status" bson:"to_status"`
	ChangedBy  string      `json:"changed_by" bson:"changed_by"`
	ChangedAt  time.Time   `json:"changed_at" bson:"changed_at" swaggertype:"string"`
	Note       string      `json:"note,omitempty" bson:"note,omitempty"`
}

// NewStatusChange creates a new StatusChange record
func NewStatusChange(alertID string, fromStatus, toStatus AlertStatus, changedBy, note string) *StatusChange {
	return &StatusChange{
		AlertID:    alertID,
		FromStatus: fromStatus,
		ToStatus:   toStatus,
		ChangedBy:  changedBy,
		ChangedAt:  time.Now().UTC(),
		Note:       note,
	}
}

// NewAlert creates a new Alert with a generated UUID
//
// Requirement: ALERT-001 - Event Preservation
// Source: docs/requirements/alert-requirements.md
// Every alert MUST preserve the complete event that triggered it for forensic analysis,
// compliance auditing, and incident response.
//
// Returns ErrNilEvent if event is nil - this is a programming error that violates ALERT-001.
// TASK 137: Replaced panic with error return for production safety.
func NewAlert(ruleID, eventID string, severity string, event *Event) (*Alert, error) {
	if event == nil {
		return nil, ErrNilEvent
	}

	return &Alert{
		AlertID:         uuid.New().String(),
		RuleID:          ruleID,
		EventID:         eventID,
		Timestamp:       time.Now().UTC(),
		Severity:        severity,
		Status:          AlertStatusPending,
		Event:           event,
		Disposition:     DispositionUndetermined, // TASK 102: Initialize with default disposition
		OccurrenceCount: 1,                       // First occurrence
	}, nil
}

// AlertMetadata holds optional metadata for enriching alerts
// Used by NewAlertWithMetadata to populate overview fields
type AlertMetadata struct {
	RuleName        string   // Rule name for display
	RuleDescription string   // Rule description
	RuleType        string   // sigma, correlation, cql, ml
	Category        string   // Alert classification (malware, phishing, intrusion, etc.)
	Source          string   // System that generated the alert
	ConfidenceScore float64  // Detection confidence 0-100
	MitreTechniques []string // MITRE ATT&CK technique IDs
}

// NewAlertWithMetadata creates a new Alert with metadata populated from rule information
// This is the preferred constructor when rule context is available
//
// Requirement: ALERT-001 - Event Preservation
// Source: docs/requirements/alert-requirements.md
// Every alert MUST preserve the complete event that triggered it for forensic analysis.
//
// The metadata parameter can be nil, in which case defaults are used.
// RiskScore is automatically calculated based on severity.
func NewAlertWithMetadata(ruleID, eventID string, severity string, event *Event, metadata *AlertMetadata) (*Alert, error) {
	if event == nil {
		return nil, ErrNilEvent
	}

	alert := &Alert{
		AlertID:         uuid.New().String(),
		RuleID:          ruleID,
		EventID:         eventID,
		Timestamp:       time.Now().UTC(),
		Severity:        severity,
		Status:          AlertStatusPending,
		Event:           event,
		Disposition:     DispositionUndetermined,
		OccurrenceCount: 1,
		RiskScore:       CalculateRiskScore(severity, 0), // Base risk from severity
	}

	// Populate metadata if provided
	if metadata != nil {
		alert.RuleName = metadata.RuleName
		alert.RuleDescription = metadata.RuleDescription
		alert.RuleType = metadata.RuleType
		alert.Category = metadata.Category
		alert.Source = metadata.Source
		alert.ConfidenceScore = metadata.ConfidenceScore
		alert.MitreTechniques = metadata.MitreTechniques
	}

	// Derive source from event if not set
	if alert.Source == "" && event != nil {
		if event.Source != "" {
			alert.Source = event.Source
		} else if event.ListenerName != "" {
			alert.Source = event.ListenerName
		}
	}

	return alert, nil
}

// CalculateRiskScore calculates a risk score (0-100) based on severity and optional modifiers
// severityWeight is an additional weight (0-50) for asset criticality, threat intel, etc.
func CalculateRiskScore(severity string, severityWeight int) int {
	// Base score from severity
	baseScore := 0
	switch severity {
	case "Critical":
		baseScore = 90
	case "High":
		baseScore = 70
	case "Medium":
		baseScore = 50
	case "Low":
		baseScore = 30
	case "Informational", "Info":
		baseScore = 10
	default:
		baseScore = 25 // Unknown severity
	}

	// Add weight (capped at 100)
	score := baseScore + severityWeight
	if score > 100 {
		score = 100
	}
	if score < 0 {
		score = 0
	}
	return score
}

// DeriveCategory derives an alert category from rule metadata
// Returns a standardized category string
func DeriveCategory(logsourceCategory, logsourceProduct string, tags []string) string {
	// Check tags first for explicit categorization
	for _, tag := range tags {
		tag = strings.ToLower(tag)
		switch {
		case strings.Contains(tag, "malware"):
			return "malware"
		case strings.Contains(tag, "phishing"):
			return "phishing"
		case strings.Contains(tag, "ransomware"):
			return "ransomware"
		case strings.Contains(tag, "intrusion") || strings.Contains(tag, "attack"):
			return "intrusion"
		case strings.Contains(tag, "exfil") || strings.Contains(tag, "data_theft"):
			return "data_exfiltration"
		case strings.Contains(tag, "credential") || strings.Contains(tag, "brute"):
			return "credential_attack"
		case strings.Contains(tag, "recon") || strings.Contains(tag, "discovery"):
			return "reconnaissance"
		case strings.Contains(tag, "lateral") || strings.Contains(tag, "movement"):
			return "lateral_movement"
		case strings.Contains(tag, "persistence"):
			return "persistence"
		case strings.Contains(tag, "privilege") || strings.Contains(tag, "escalation"):
			return "privilege_escalation"
		case strings.Contains(tag, "c2") || strings.Contains(tag, "command"):
			return "command_and_control"
		}
	}

	// Fall back to logsource category if available
	if logsourceCategory != "" {
		cat := strings.ToLower(logsourceCategory)
		switch {
		case strings.Contains(cat, "process"):
			return "process_anomaly"
		case strings.Contains(cat, "network"):
			return "network_anomaly"
		case strings.Contains(cat, "file"):
			return "file_anomaly"
		case strings.Contains(cat, "registry"):
			return "registry_anomaly"
		case strings.Contains(cat, "authentication") || strings.Contains(cat, "logon"):
			return "authentication"
		}
	}

	return "security_alert" // Generic fallback
}
